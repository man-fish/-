# 闭包实现备忘模式和高阶函数

# 1.闭包

### 1.1 什么是闭包

当函数可以**记住并访问**所在的词法作用域时，就产生了**闭包**，即使函数是在当前词法作用域之外执行。

> **注意：** 如果不是必须使用闭包，那么尽量避免创建它，因为闭包在处理速度和内存消耗方面对性能具有负面影响。

我们首先来看一个闭包的例子：

```javascript
function foo() {
    var a = 2
    
    function bar() {
        console.log(a)
    }
    
    return bar
}

var baz = foo()

baz()            // 输出: 2
```

> `foo` 函数传递出了一个函数 `bar`，传递出来的 `bar` 被赋值给 `baz` 并调用，虽然这时 `baz` 是在 `foo` 作用域外执行的，但 `baz` 在调用的时候可以访问到前面的 `bar` 函数所在的 `foo` 的内部作用域。由于 `bar` 声明在 `foo` 函数内部，`bar` 拥有涵盖 `foo` 内部作用域的闭包，使得 `foo` 的内部作用域一直存活不被回收。一般来说，函数在执行完后其整个内部作用域都会被销毁，因为 JavaScript 的 GC（Garbage Collection）垃圾回收机制会自动回收不再使用的内存空间。但是闭包会阻止某些 GC，比如本例中 `foo()` 执行完，因为返回的 `bar` 函数依然持有其所在作用域的引用，所以其内部作用域不会被回收。

### 1.2 利用闭包实现备忘模式

```js
function memorzie(fn){
    let cache = {}
    //创建复杂函数缓存对象
    return function(...args){
        //将处理的复杂函数的参数转化为数组
        let key = JSON.stringify(args)
        //将数组转化为字符串
        let cacheKeys = Object.keys(cache)
        //获取当前缓存对象的键
        if(cacheKeys.length >= 20){
                let firstKey = cacheKeys[0]
                delete cache[firstKey]
        }
        //如果缓存对象过大就清除掉一部分键值对
        return cache[key] || (cache[key] = fn.apply(fn,args))
        //如果缓存对象的键中当前调用函数的参数就直接返回，否则进行计算
    }
}

function add(a){
        return a+1
}
//复杂函数

const adder = new memorzie(add)

adder(1345678)
adder(13456789)
adder(23456789)
adder(23456789)
```

**稍微解释一下：**

备忘函数中用 `JSON.stringify` 把传给 `adder` 函数的参数序列化成字符串，把它当做 `cache` 的索引，将 `add` 函数运行的结果当做索引的值传递给 `cache`，这样 `adder` 运行的时候如果传递的参数之前传递过，那么就返回缓存好的计算结果，不用再计算了，如果传递的参数没计算过，则计算并缓存 `fn.apply(fn, args)`，再返回计算的结果。

当然这里的实现如果要实际应用的话，还需要继续改进一下，比如：

1. 缓存不可以永远扩张下去，这样太耗费内存资源，我们可以只缓存最新传入的 n 个；
2. 在浏览器中使用的时候，我们可以借助浏览器的持久化手段，来进行缓存的持久化，比如 cookie、localStorage 等；

这里的复杂计算函数可以是过去的某个状态，比如对某个目标的操作，这样把过去的状态缓存起来，方便地进行状态回退。

复杂计算函数也可以是一个返回时间比较慢的异步操作，这样如果把结果缓存起来，下次就可以直接从本地获取，而不是重新进行异步请求。

## 2. 高阶函数

**高阶函数**就是输入参数里有函数，或者输出是函数的函数。

### 2.1 函数作为参数

如果你用过 `setTimeout`、`setInterval`、ajax 请求，那么你已经用过高阶函数了，这是我们最常看到的场景：**回调函数**，因为它将函数作为参数传递给另一个函数。

比如 ajax 请求中，我们通常使用回调函数来定义请求成功或者失败时的操作逻辑：

```javascript
$.ajax("/request/url", function(result){
    console.log("请求成功！")
})
```

在 Array、Object、String 等等基本对象的原型上有很多操作方法，可以接受回调函数来方便地进行对象操作。这里举一个很常用的 `Array.prototype.filter()` 方法，这个方法返回一个新创建的数组，包含所有回调函数执行后返回 `true` 或真值的数组元素。

```javascript
var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

var result = words.filter(function(word) {
    return word.length > 6
})       // 输出: ["exuberant", "destruction", "present"]
```

回调函数还有一个应用就是钩子，如果你用过 Vue 或者 React 等框架，那么你应该对钩子很熟悉了，它的形式是这样的：

```javascript
function foo(callback) {
    // ... 一些操作
    callback()
}
```

### 2.2 函数作为返回值

另一个经常看到的高阶函数的场景是在一个函数内部输出另一个函数，比如：

```js
function foo() {
    return function bar() {}
}
```

主要是利用闭包来保持着作用域：

```js
function add() {
    var num = 0
    return function(a) {
        return num = num + a
    }
}
var adder = add()

adder(1)     // 输出: 1
adder(2)     // 输出: 3
```

#### 