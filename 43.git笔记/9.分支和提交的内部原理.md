# 分支和提交的内部原理

#### commit的过程

现在我们知道了，.git内部的结构以及git的三大对象。我们可以先来了解一下commit的过程，如果进行了一些更改并再次提交，则下一个提交将存储指向紧接在其之前的提交的指针。

![承诺和他们的父母。](https://git-scm.com/book/en/v2/images/commits-and-parents.png)

#### 分支创建的过程

##### master主分支

Git中的分支只是指向这些提交之一的轻量级可移动指针。Git中的默认分支名称为`master`。当您开始进行提交时，您会得到一个`master`分支，该分支指向您所做的最后一次提交。每次提交时，`master`分支指针都会自动向前移动。

> **注意**: Git中的“ master”分支不是特殊分支。就像其他任何分支一样。几乎每个存储库都拥有一个存储库的唯一原因是该`git init`命令默认情况下会创建该存储库，并且大多数人都不会去更改它。

![分支及其提交历史。](https://git-scm.com/book/en/v2/images/branch-and-history.png)

##### 创建一个新分支

创建新分支时会发生什么？好吧，这样做会创建一个新的指针供您移动。假设您要创建一个名为的新分支`testing`。您可以使用以下`git branch`命令执行此操作：

```bash
$ git branch testing
```

这将创建一个新指针，指向您当前正在执行的同一提交，那么Git如何知道您当前在哪个分支？它保留一个称为的特殊指针`HEAD`。

> 在Git中，这是指向您当前所在的本地分支的指针。在这种情况下，您仍然在`master`。该`git branch`命令仅*创建*了一个新分支-并未切换到该分支。

![HEAD指向分支。](https://git-scm.com/book/en/v2/images/head-to-master.png)

对应着实际的文件来说我们其实是在heads文件夹里创建了一个testing分支，同时里面保存着当前commit的地址（hash）![1572852730032](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1572852730032.png)

#### 切换分支

要切换到现有分支，请运行`git checkout`命令。让我们切换到新`testing`分支：

```bash
$ git checkout testing
```

这将`HEAD`指向`testing`分支。

![HEAD指向当前分支。](https://git-scm.com/book/en/v2/images/head-to-testing.png)

那有什么意义？好吧，让我们再做一次提交：

```bash
$ git commit -a -m 'made a change'
```

![提交后，HEAD分支将向前移动。](https://git-scm.com/book/en/v2/images/advance-testing.png)

这很有趣，因为现在您的`testing`分支已经向前移动，但是您的`master`分支仍然指向您在`git checkout`切换分支时所进行的提交。让我们切换回`master`分支：

```bash
$ git checkout master
```

![结帐时HEAD移动。](https://git-scm.com/book/en/v2/images/checkout-master.png)

该命令做了两件事。它将HEAD指针移回指向`master`分支，并将工作目录中的文件还原回指向的快照`master`。这也意味着您从现在开始所做的更改将与项目的旧版本有所不同。从本质上讲，它`testing`可以使您在分支机构中完成的工作后退，从而可以朝另一个方向发展。

> **注意**
>
> More Actions切换分支会更改您的工作目录中的文件重要的是要注意，当您在Git中切换分支时，工作目录中的文件将会更改。如果切换到较旧的分支，则工作目录将还原为上次在该分支上提交时的工作目录。如果Git无法做到干净整洁，它将根本让您无法切换。