# CORS跨域请求限制和解决

## 引言

### 什么是跨域

1995年由Netscape提出同源策略，浏览器在发送Ajax请求时，只接收同域服务器响应的数据资源；那么什么才算同域呢？很简单，协议、域名、端口全部相同才算同一域下，三个条件有一个不一致，都不算同域，既跨域；如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。

![url的组成](https://user-gold-cdn.xitu.io/2018/5/23/1638b3579d9eeb32?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

比如我们在浏览器中的127.0.0.1:3000端口下使用ajax请求（script或者是src就不会造成此效果）访问了127.0.0.1:8080端口的数据，就会造成非法跨域现象，无法取得返回的数据。

### 跨域的实质

当我们在一个域名下访问另一个域名的数据时，这种请求时必须被服务器允许的（允许外域请求），如果不被允许，我们虽然可以通过http请求请求到服务端发来的响应报文，但是在浏览器拿到响应报文时，发现服务器所在域名和我们当前的域名不同且没有在响应报文的头中拿到服务器的许可，会自动拦截并且报错。



## 服务端的解决方案

### CORS

##### 服务器的许可证

```json
header:{
	"Access-Control-Allow-Origin" : "*"
}
```

只要浏览器响应头中看到了这个字段就不会拦截响应报文。

##### Access-Control-Allow-Origin

”*“ 代表的是允许来自所有域的请求

value值也可也设置为另一个域名（只能设置一个），不过当我们这个服务器想允许多个域名下的跨域请求时，我们也可以这样处理。

```js
const http = require("http")

http.createServer((req,res)=>{
        if(req.headers.host.endsWith("3000")){
            res.writeHead(200,{
                "Content-Type" : "application/json",
                "Access-Control-Allow-Orign" : "http://127.0.0.1:3000"
            })
        }else if(req.headers.host.endsWith("8080")){
            res.writeHead(200,{
                "Content-Type" : "application/json",
                "Access-Control-Allow-Orign" : "http://127.0.0.1:8080"
            })
        }

        res.end(JSON.parse(req))
}).listen(3000)
```

##### 允许预设的不同域名的跨域请求

```js
const http = require("http")

http.createServer(function(req,res){
    const originUrl = req.headers.origin
    					//获取请求页面来源的地址
    const allowUrl = ['http://127.0.0.1:3000','http://127.0.0.1:8080']
    
    if(allowUrl.include(originUrl)){
         res.writeHead(200,{
            'Access-Control-Allow-Origin' : `${req.headers.origin}`,
                                           //只能有一个地址，所以要自己根据请求路径做处理。
        })
    }

    res.end("123")
}).listen(8887)

console.log("server has runned on port 8887")
```

#### 其他限制

虽然现在我们已经可以进行请求了，但是这种跨域请求仍然有一些限制。以下是允许的字段。

> **请求方法**：GET,POST,HEAD
>
> **请求头限制**：
>
> > ‘Accept’  : "*"
> >
> > 'Accrpt-Language' : "*"
> >
> > 'Content-Language' : "*"
> >
> > Content-Type："text/plain","multipart/form-data","application/x-www-form-urlencoded"

##### 浏览器机制--预请求

当我们的请求与当前域不同时且请求头出现了限制字段或者请求放发受到限制时，就会先发送头体信息相同请求方法为OPTION的预请求，如果说预请求通过了就发送正式请求。

![1571639056153](F:\我的笔记\image\1571639056153.png)

可以看到当我们设置了请求头中有x-test-cors的自定义请求头字段时，浏览器会先发送options请求，拿到响应头之后，将Access-Control-Request-Headers和我们的自定义请求头字段做对比，如果有，则发送正式请求。

##### 服务器的许可证

```js
{
	"Access-Control-Allow-Origin" : "*"，
	"Access-Control-Allow-Headers" : "*",//请求头字段
	"Access-Control-Allow-Methods" : "post,get,option,delete",//方法名
	"Access-Control-Max-Age" : "1000"	//设置许可时间（秒）相同域名下一次就不需要预请求了
}
```



### Node中间件代理(两次跨域)

实现原理：**同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。** 代理服务器，需要做以下几个步骤：

- 接受客户端请求 。

- 将请求 转发给服务器。

- 拿到服务器 响应 数据。

- 将 响应 转发给客户端。 

  ![img](https://user-gold-cdn.xitu.io/2019/1/17/1685c5bed77e7788?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

我们先来看个例子：本地文件index.html文件，通过代理服务器`http://localhost:3000`向目标服务器`http://localhost:4000`请求数据。

```JS
// index.html(http://127.0.0.1:5500)
 <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
    <script>
      $.ajax({
        url: 'http://localhost:3000',
        type: 'post',
        data: { name: 'xiamen', password: '123456' },
        contentType: 'application/json;charset=utf-8',
        success: function(result) {
          console.log(result) // {"title":"fontend","password":"123456"}
        },
        error: function(msg) {
          console.log(msg)
        }
      })
     </script>
复制代码
// server1.js 代理服务器(http://localhost:3000)
const http = require('http')
// 第一步：接受客户端请求
const server = http.createServer((request, response) => {
  // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段
  response.writeHead(200, {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': '*',
    'Access-Control-Allow-Headers': 'Content-Type'
  })
  // 第二步：将请求转发给服务器
  const proxyRequest = http
    .request(
      {
        host: '127.0.0.1',
        port: 4000,
        url: '/',
        method: request.method,
        headers: request.headers
      },
      serverResponse => {
        // 第三步：收到服务器的响应
        var body = ''
        serverResponse.on('data', chunk => {
          body += chunk
        })
        serverResponse.on('end', () => {
          console.log('The data is ' + body)
          // 第四步：将响应结果转发给浏览器
          response.end(body)
        })
      }
    )
    .end()
})
server.listen(3000, () => {
  console.log('The proxyServer is running at http://localhost:3000')
})
复制代码
// server2.js(http://localhost:4000)
const http = require('http')
const data = { title: 'fontend', password: '123456' }
const server = http.createServer((request, response) => {
  if (request.url === '/') {
    response.end(JSON.stringify(data))
  }
})
server.listen(4000, () => {
  console.log('The server is running at http://localhost:4000')
})
复制代码
```

上述代码经过两次跨域，值得注意的是浏览器向代理服务器发送请求，也遵循同源策略，最后在index.html文件打印出`{"title":"fontend","password":"123456"}`



## 客户端的解决方案

### **JSONP**

##### 1) JSONP原理

**利用 <script> 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP请求一定需要对方的服务器做支持才可以。**

##### 2) JSONP和AJAX对比

JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器端获取数据的方式。但AJAX属于同源策略，JSONP属于非同源策略（跨域请求）

##### 3) JSONP优缺点

JSONP优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。**缺点是仅支持get方法具有局限性,不安全可能会遭受XSS攻击。**

##### 4) JSONP的实现流程

- 声明一个回调函数，其函数名(如show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的data)。
- 创建一个`<script>`标签，把那个跨域的API数据接口地址，赋值给script的src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。
- 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是show，它准备好的数据是`show('我不爱你')`。
- 最后服务器把准备的数据通过HTTP协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP函数。

```JS
// index.html
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script')
    //先创建一个script
    window[callback] = function(data) {
      resolve(data)
      document.body.removeChild(script)
    }
    //在全局注册要执行的回调函数
    params = { ...params, callback } // wd=b&callback=show
    let arrs = []
    for (let key in params) {
      arrs.push(`${key}=${params[key]}`)
    }
    script.src = `${url}?${arrs.join('&')}`
    //拼凑规定格式的url
    document.body.appendChild(script)
    //发送请求，我们拿到返回的东西之后，script会自动执行其内容，也就是show(data)
  })
}
jsonp({
  url: 'http://localhost:3000/say',
  params: { wd: 'Iloveyou' },
  callback: 'show'
}).then(data => {
  console.log(data)
})
```

上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&callback=show这个地址请求数据，然后后台返回show('我不爱你')，最后会运行show()这个函数，打印出'我不爱你'

```js
// server.js
let express = require('express')
let app = express()
app.get('/say', function(req, res) {
  let { wd, callback } = req.query
  console.log(wd) // Iloveyou
  console.log(callback) // show
  res.end(`${callback}('我不爱你')`)
})
app.listen(3000)
```

###### 