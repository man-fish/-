词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段，同时，对于函数作用域，无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。

```js
function foo() { 
  console.log( a ); // 2 
}
function bar() {
	var a = 3; foo(); 
}
var a = 2; bar();
```

词法作用域让 foo() 中的 a 通过 RHS 引用到了全局作用域中的 a，因此会输出 2。

同样是词法作用域的语言还有 GOLANG

```go
func bar() {
	fmt.Println(a)
}

func foo() {
	var a = 1
	bar()
	fmt.Println(a)
}

var a = 2

func main() {
	foo()
}
```

而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。 

因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出 3。

```js
function foo() { console.log( a ); // 3（不是 2 ！） }
function bar() {
var a = 3; foo(); }
var a = 2; bar();
```

为什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地 方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的， 引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。

最后需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域。 不过 this 机制某种程度上很像动态作用域。

