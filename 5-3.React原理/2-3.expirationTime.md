## 1. `React` 更新时间计算规则

> all from [react-reconciler/ReactFiberReconciler.js]()

`react` 中的时间单位是基于 `10ms` 的我们姑且将这个时间单位称为 `rs` ，如下面的 `UNIT_SIZE` 就是用于初始化时间戳的(时间戳是以 `ms` 为单位的)。

之后让我们分析下面的时间计算公式 `((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET`，由于 `/` 操作会产生小数，所以我们要 `| 0` 取个整，

```ts
const UNIT_SIZE = 10;
const MAGIC_NUMBER_OFFSET = 2;

// 1 unit of expiration time represents 10ms.
export function msToExpirationTime(ms: number): ExpirationTime {
  // Always add an offset so that we don't clash with the magic number for NoWork.
  return ((ms / UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;
}
```

之后还要加上一个魔数 `2`，这是因为时间量中有两个特殊量被 `react` 用作标识位了 `NoWork` 和 `Sync` 而加上魔数就是为了避开标识量。

```ts
export const NoWork = 0;
export const Sync = 1;
export const Never = MAX_SIGNED_31_BIT_INT;
```

有了这些规则之后，`react` 在 `bundle` 初始化的时候会计算出三个时间量 `originalStartTimeMs` 即 `js` 加载完成的时间的时间戳，`currentRendererTime` 和 `currentSchedulerTime` 用作后续计算使用。

```ts
let originalStartTimeMs: number = now();
let currentRendererTime: ExpirationTime = msToExpirationTime(
  originalStartTimeMs,
);
let currentSchedulerTime: ExpirationTime = currentRendererTime;
```

每次重新计算 `currentRendererTime` 都是根据当前时间和 `js` 第一次加载的时间：

```ts
function recomputeCurrentRendererTime() {
  const currentTimeMs = now() - originalStartTimeMs;
  currentRendererTime = msToExpirationTime(currentTimeMs);
}
```

### 1.1 currentTime

有了上面定义的时间规则我们就可以看看 `requestCurrentTime` 获取 `currentTime`，在 `React` 中我们计算`expirationTime`要基于当前得*时钟时间*，一般来说我们只需要获取`Date.now`就可以了。

但是每次获取一下比较消耗性能，所以 React 设置了`currentRendererTime`来记录这个值，用于一些不需要重新计算得场景。

```ts
function requestCurrentTime() {
  if (isRendering) { // 忽略，因为我们当前第一次挂在节点没在渲染
    // We're already rendering. Return the most recently read time.
    return currentSchedulerTime;
  }
  // Check if there's pending work.
  // 调度相关，忽略
  findHighestPriorityRoot();
  if (
    // 成立
    nextFlushedExpirationTime === NoWork ||
    nextFlushedExpirationTime === Never
  ) {
    // If there's no pending work, or if the pending work is offscreen, we can
    // read the current time without risk of tearing.
    recomputeCurrentRendererTime();
    currentSchedulerTime = currentRendererTime;
    return currentSchedulerTime;
  }
  // There's already pending work. We might be in the middle of a browser
  // event. If we were to read the current time, it could cause multiple updates
  // within the same event to receive different expiration times, leading to
  // tearing. Return the last read time. During the next idle callback, the
  // time will be updated.
  return currentSchedulerTime;
}
```

比如说：

```ts
if (isRendering) {
  return currentSchedulerTime
}
```

这个`isRendering`只有在`performWorkOnRoot`的时候才会被设置为`true`，而其本身是一个同步的方法，不存在他执行到一半没有设置`isRendering`为`false`的时候就跳出，那么什么情况下会在这里出现新的`requestCurrentTime`呢？

- 在生命周期方法中调用了`setState`
- 需要挂起任务的时候

也就是说 React 要求**在一次`rendering`过程中，新产生的`update`用于计算过期时间的`current`必须跟目前的`renderTime`保持一致，同理在这个周期中所有产生的新的更新的过期时间都会保持一致！**

然后是第二个判断：

```ts
if (
  nextFlushedExpirationTime === NoWork ||
  nextFlushedExpirationTime === Never
)
```

也就是说在一个 `batched` 更新中，只有第一次创建更新才会重新计算时间，后面的所有更新都会复用第一次创建更新的时候的时间，这个也是为了保证在一个批量更新中产生的同类型的更新只会有相同的过期时间。

### 1.2 expirationTime

`expirationTime` 指的是任务可以被抢占的最晚更新时间(为了防止任务被持续打断)，`react` 中有两类的任务是可以被打断的异步任务，一个是`Interactive`(人机交互)的，`Interactive`的比如说是由事件触发的，那么他的响应优先级会比较高因为涉及到交互：

```ts
export const HIGH_PRIORITY_EXPIRATION = __DEV__ ? 500 : 150;
export const HIGH_PRIORITY_BATCH_SIZE = 100;

export function computeInteractiveExpiration(currentTime: ExpirationTime) {
  return computeExpirationBucket(
    currentTime,
    HIGH_PRIORITY_EXPIRATION,
    HIGH_PRIORITY_BATCH_SIZE,
  );
}
```

另一种是普通的异步 `async`：

```ts
export const LOW_PRIORITY_EXPIRATION = 5000;
export const LOW_PRIORITY_BATCH_SIZE = 250;

export function computeAsyncExpiration(
  currentTime: ExpirationTime,
): ExpirationTime {
  return computeExpirationBucket(
    currentTime,
    LOW_PRIORITY_EXPIRATION,
    LOW_PRIORITY_BATCH_SIZE,
  );
}
```

而他们的基础公式为：

```ts
function computeExpirationBucket(
  currentTime,
  expirationInMs,
  bucketSizeMs,
): ExpirationTime {
  return (
    MAGIC_NUMBER_OFFSET(2) +
    ceiling(
      currentTime - MAGIC_NUMBER_OFFSET(2) + expirationInMs(5000) / UNIT_SIZE(10),
      bucketSizeMs(250) / UNIT_SIZE,
    )
  )
}
```

在整个计算公式中只有`currentTime`是变量，也就是当前的时间戳。我们拿`computeAsyncExpiration`举例，在`computeExpirationBucket`中接收的就是`currentTime`、`5000`和`250`:

然后来看看工具函数 `ceil`，我们知道 `Math.ceil` 是以 `1` 为精度向下取整，可以看成 `(num/1|0)`，所以式子里面的 `precision` 就是精度：

```TS
function ceiling(num: number, precision: number): number {
  return (((num / precision) | 0) + 1) * precision
}
```

联系上面的讲解之后我们知道最终的计算公式就是这样的：`((((currentTime - 2 + 5000 / 10) / 25) | 0) + 1) * 25` ，首先通过  `(currentTime - 2 + 5000 / 10)` 计算出在 `async` 或者 `interactive` 状态优先级 (`LOW_PRIORITY_EXPIRATION` / `HIGH_PRIORITY_EXPIRATION`)下的下次更新时间 `expirationTime`，之后按精度(`LOW_PRIORITY_BATCH_SIZE`/ `HIGH_PRIORITY_BATCH_SIZE`) 取整防止出现太多的更新优先级。

因为我们一开始减去魔数了嘛，所以最后我们还要给他加上。

```ts
let expirationContext: ExpirationTime = NoWork;
```

```ts
function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) {
  let expirationTime;
  if (expirationContext !== NoWork) {
    // An explicit expiration context was set;
    expirationTime = expirationContext;
  } else if (isWorking) {
    if (isCommitting) {
      // Updates that occur during the commit phase should have sync priority
      // by default.
      expirationTime = Sync;
    } else {
      // Updates during the render phase should expire at the same time as
      // the work that is being rendered.
      expirationTime = nextRenderExpirationTime;
    }
  } else {
    // No explicit expiration context was set, and we're not currently
    // performing work. Calculate a new expiration time.
    if (fiber.mode & ConcurrentMode) {
      if (isBatchingInteractiveUpdates) {
        // This is an interactive update
        expirationTime = computeInteractiveExpiration(currentTime);
      } else {
        // This is an async update
        expirationTime = computeAsyncExpiration(currentTime);
      }
      // If we're in the middle of rendering a tree, do not update at the same
      // expiration time that is already rendering.
      if (nextRoot !== null && expirationTime === nextRenderExpirationTime) {
        expirationTime += 1;
      }
    } else {
      // This is a sync update
      expirationTime = Sync;
    }
  }
  if (isBatchingInteractiveUpdates) {
    // This is an interactive update. Keep track of the lowest pending
    // interactive expiration time. This allows us to synchronously flush
    // all interactive updates when needed.
    if (expirationTime > lowestPriorityPendingInteractiveExpirationTime) {
      lowestPriorityPendingInteractiveExpirationTime = expirationTime;
    }
  }
  return expirationTime;
}
```



```ts
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,
  callback: ?Function,
): ExpirationTime {
  const current = container.current
  const currentTime = requestCurrentTime()
  const expirationTime = computeExpirationForFiber(currentTime, current)
  
  
    element,
    container,
    parentComponent,
    expirationTime,
    callback,
  )
}
```







