# 数据监听

### compute和watch

> **watch** 和 **compute** 要控制不修改你监听的属性值，他们要做的事应该只是监听和处理。

### compute  处理

```js
import Vue from "vue"

const app = new Vue({
        template:`<div>
                    <p>{{fullname}}</p>
                    <p>{{getName()}}</p>
                </div>` ,
        data:{
            firstName:"wang",
            lastName:"bo"
        },
        computed:{
            fullname(){
                return `${this.firstName}${this.lastName}`
            }
        }
        methods:{
            getName(){
                return `${this.firstName}${this.lastName}`
            }
        }
    })

app.$mount("#root")
```

有缓存，页面渲染时依赖值不改变就不会造成二次计算。

```js
import Vue from "vue"
import { get } from "http";

const app = new Vue({
        template:`<div>
                    <p>{{name}}</p>
                </div>` ,
        data:{
            firstName:"wang",
            lastName:"bo",
        },
        computed:{
            nousename:{
                get(){

                },
                setImmediate(){

                }
            }
        },
        methods:{
            getName(){
                return `${this.firstName}${this.lastName}`
            }
        }
    })

app.$mount("#root")
```

computed也可以用来设置值，完全不推荐，可能会造成循环渲染。

### watch  监听

```js
    import Vue from "vue"

    const app = new Vue({
            template:`<div>
                        <p>{{fullname}}</p>
                        <p><input type="text" v-model="firstName" /></p>
                        <p><input type="text" v-model="lastName" /></p>
                    </div>` ,
            data:{
                firstName:"wang",
                lastName:"bo",
                fullname:"",
            },
            watch:{
                firstName(oldname,newname){
                      	this.fullname = newname+oldname
                }
            }
        })

    app.$mount("#root")
```

这里我们可以看到，一开始的时候fullname是不会渲染的。

```js
    import Vue from "vue"

    const app = new Vue({
            template:`<div>
                        <p>{{fullname}}</p>
                        <p><input type="text" v-model="firstName" /></p>
                        <p><input type="text" v-model="lastName" /></p>
                    </div>` ,
            data:{
                firstName:"wang",
                lastName:"bo",
                fullname:"",
            },
            watch:{
                firstName:{
                    handler(oldname,newname){
						this.fullname = newname+oldname
                    },
                    immediate:true,
                }
            }
        })

    app.$mount("#root")
```

但是我们也可已使用以下写法让渲染立刻执行，但是数据展示不用watch。

```js
    import Vue from "vue"
    import { get } from "http";

    const app = new Vue({
            template:`<div></div>` ,
            data:{
                obj:{
                    a:1,
                    b:2
                }
            },
            watch:{
                obj:{
                        handler(oldname,newname){

                        },
                        immediate:true,
                        deep:true
                }
                
            }
        })

    app.$mount("#root")

	setTimeOut(()=>{
        app.data.obj.a = 3
    },1000)
```

watch在没有deep属性有的时候是不会监听对象内部的属性。

```js
    import Vue from "vue"
    import { get } from "http";

    const app = new Vue({
            template:`<div></div>` ,
            data:{
                obj:{
                    a:1,
                    b:2
                }
            },
            watch:{
                'obj.a':{
                        handler(oldname,newname){

                        },
                        immediate:true,
                }
            }
        })

    app.$mount("#root")

	setTimeOut(()=>{
        app.data.obj.a = 3
    },1000)
```

这样写对性能来说更加友善。