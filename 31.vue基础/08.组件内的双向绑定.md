# 双向绑定2.0

在一个vue实例上，只要给input标签一个v-model属性就可以很轻松的实现一个数据的双向绑定，但是你要是想把组件里面的input来和外面的引用实例的data数据建立连系，只使用v-model就没法轻易的实现这种效果了。

```js
import Vue from "vue"

const component = {
    props:["value"],
    template:`
        <div>
            <input type="text" @input="handleInput"  :value="value">
        </div>
    `,
    methods:{
        handleInput(e){
            this.$emit('input',e.target.value)
            //只要把原生的value向上暴露，然后在上层使用v-model接收一下就行了。
        }
    }
}

new Vue({
    components:{
        CompOne:component
    },
    el:'#root',
    data:{
            value:"123"
    },
    template:`
        <div>
            <comp-one :value = "value" @input="value = arguments[0]"></comp-one>
        </div>
    `,
    template:`
        <div>
            <comp-one v-model="value"></comp-one>
        </div>
    `
})
```

**v-model**在一个组件里面实现的就是 **:value = "value" @input="value = arguments[0]"**，这两行语句，

 **:value = "value"**

> 把value传入到prop之中。

**@input="value = arguments[0]"**

> 动态的根据下面传递过来的值修改data中的value。

```js
new Vue({
    components:{
        CompOne:component
    },
    el:'#root',
    data:{
            value:"123"
    },
    template:`
        <div>
            <comp-one v-model="value" :value = "value" @input="value = arguments[0]"></comp-one>
        </div>
        <input type="text" :value="value" @input="value=arguement[0]">
    `
})
```

> 其实这个和普通的单项数据流的唯一区别就是input事件是我们主动向上暴露的，
>
> **@input="value = arguments[0]"**也就是这个的出发原因不同

