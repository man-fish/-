# Vue实例

### 基础结构

```js
import Vue from "vue"

const app = new Vue({
    el:"#root",
    template:"<div>{{text}}</div>",
    data:{
        text:'text',
    }
})
```

### 元素挂载

```js
import Vue from "vue"

const app = new Vue({
    el:"#root",
    template:"<div>{{text}}</div>",
    data:{
        text:'text',
    }
})

//或者

const app = new Vue({
    template:"<div>{{text}}</div>",
    data:{
        text:'text',
    }
})

app.$mount("#root")
```

被挂载的元素会自动充当外层元素（不管他原来是一个div还是一个p），他都会被先销毁再重建成你template里的东西，之前用于定位的root也随之消失。

### 数据以及数据更新

#### 数据获取

app.$data

app.$options.data

#### 数据更新

vue是一个响应式框架，而未声明的对象属性是非响应式的元素，给非响应式的元素设置非响应式的的元素值，不会引起组件实例重新渲染。

```js
setInterval(()=>{
    app.text += 1                   //有效
    app.$data.text += 1             //有效
    app.$options.data.text = 1      //无效,影响的不是同一个data对象。
    app.obj.a = 1					//无效
    app.$forceUpdate();				//有效
    app.$set(app.obj,"a",1)			//有效
},1000)

```

##### *$forceUpdate \& \$set ( api )*

使用  ***$forceUpdate***  可以解决这个问题，强制重新渲染。 但是这样子不好强制重新渲染降低性能。

使用  ***$set***  就很像微信的this.setData(),只是vue是不能渲染为声明过的值，而wx小程序是this.data.xx = xx;不会引起重新渲染。

#### 数据监听

```js
import Vue from "vue"

const app = new Vue({
    template:"<div>{{text}}</div>",
    data:{
        text:'text',
        watch:("text",(n,o)=>{
                console.log(n,o)
        })
    }
})

app.$mount("#root")

setInterval(()=>{
    app.text += 1 
},1000)

app.$watch("text",(newText,oldText)=>{
        console.log(newText,oldText)
})
setTimeOunt(()=>{unWatch();},1000)
// 组件监听属性值的改变。
/**
 * 参数一 ：要监听的属性名称。
 * 这种函数一定要记得手动停止，不然在页面切换的时候不会注销有可能导致内存溢出。
 * 当然直接写在实例属性里面就不会发生了。
 */
```

##### *$watch && watch*

### 实例属性

##### app.$data

> 获取data里面的数据。

##### app.$el

> 获取组件dom对象。

##### app.$options

> 获取一些组件属性，经过了二次处理。

##### app.$props

> 获取传入数据

##### app.$options.render= (h)=>{  return h('div',{},'new render function')}

> 真实加载方法

##### app.$root === app

> 返回组件自身实例

##### app.$children

> 返回子组件实例

##### app.$slots

> 返回插槽实例

##### app.$refs

```js
const app = new Vue({
    el:"#root",
    template:"<div ref = 'node'>this is a vue {{text}}.</div>",
    data:{
        text:'text'
    }
})

console.log(app.$refs)
```

> 返回组件中有 refs 属性的 html 元素对象或者是组件实例

##### app.$isServer

> 判断是否是服务器环境



### 实例方法

##### app.$watch

```js
app.$watch("text",(newText,oldText)=>{
        console.log(newText,oldText)
})

setTimeOunt(()=>{unWatch();},1000)
```

> 1. 组件监听属性值的改变。
> 2. 参数一 ：要监听的属性名称。
> 3.  这种函数一定要记得手动停止，不然在页面切换的时候不会注销有可能导致内存溢出。

##### app.$on

```js
app.$on('test',(a,b)=>{
    console.log('test')
})

app.$emit("test",1,2)
//每次都监听


app.$once("text",(a,b)=>{
     console.log(1)
})

app.$emit("text")
app.$emit("text")
//只监听一次
```

> 无事件冒泡，触发事件和监听事件调用对象必须相同。

##### app.$nextTick

```js
app.$nextTick(()=>{
    console.log("vue的重新渲染")
})
```

> vue是异步渲染的，可能我们一次对dom进行了很多次操作，但是vue之渲染一次，这个函数能监听vue的每次重新渲染。

