# vue-router 导航守卫

> 『导航』表示路由正在发生改变

导航守卫主要用来通过跳转或取消的方式守卫导航。注意**参数或查询的改变并不会触发进入/离开的导航守卫**。可以通过[观察 `$route` 对象](https://router.vuejs.org/zh-cn/essentials/dynamic-matching.html#响应路由参数的变化)来应对这些变化。

### 全局守卫

守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 **等待中**。所以**确保要调用 next 方法，否则钩子就不会被 resolved**。

#### 全局前置守卫

使用 router.beforeEach 注册一个全局前置守卫

```js
const router = new VueRouter({ ... })
router.beforeEach((to, from, next) => {
    if(tofullPath == "/app"){
        next({path:'/login',replace })
    }else{
        next()
    }
})
```

 参数校验，在跳转之前就可以执行。比如没有cookie就跳登录

#### 全局解析守卫

在 2.5.0+ 你可以用 router.beforeResolve 注册一个全局守卫。这和 router.beforeEach 类似，区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。

```js
router.beforeResolve((to,from,next)=>{
    console.log("before each resolve")
    next()
})
```

#### 全局后置钩子

你也可以注册全局后置钩子，然而和守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身：

```js
router.afterEach((to, from) => {
  // ...
})
```

### 路由独享的守卫

```js
const router = new VueRouter({
  routes: [
    {
      path: '/foo',
      component: Foo,
      beforeEnter: (to, from, next) => {
        // ...
      }
    }
  ]
})
```

### 组件内的守卫

> beforeRouteEnter
>
> beforeRouteUpdate (2.2 新增)
>
> beforeRouteLeave

#### beforeRouteEnter

```js
beforeRouteEnter (to, from, next) {
  next(vm => {
    // 通过 `vm` 访问组件实例
  })
}
```

需要注意的是beforeRouteEnter不能访问this，可以通过传一个回调给 next来访问组件实例。

#### beforeRouteUpdate

```js
beforeRouteUpdate(to,after,next){
	next()
}
```

我们经常在组件中注册mounted来进行对组件进行一些更新，但是在路由改变造成相同组件的渲染时，mounted是不会触发的，这个时候这个守卫就很好用了。

#### beforeRouterLeave

```js
beforeRouteLeave(){
    if(global.confirm('are you sure?')){
    	next()
    }
}
```

你真的要离开这个页面么。

### 整体流程

> 1.  导航被触发。
> 2. 在失活的组件内调用离开守卫beforeRouteLeave。
> 3. 调用全局的 beforeEach 守卫。
> 4. 在重用的组件内调用 beforeRouteUpdate 守卫 (2.2+)。
> 5. 在路由配置里调用独享守卫 beforeEnter。
> 6. 解析异步路由组件。
> 7. 在被激活的组件内调用 beforeRouteEnter。
> 8. 调用全局的 beforeResolve 守卫 (2.5+)。
> 9. 导航被确认。
> 10. 调用全局的 afterEach 钩子。
> 11. 触发 DOM 更新。
> 12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。