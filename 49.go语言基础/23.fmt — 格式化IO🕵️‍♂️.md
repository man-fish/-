# fmt — 格式化IO🕵️‍♂️

> fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf. 格式“占位符”衍生自C，但比C更简单，fmt包不是用来实现控制台输出的重要的事情说100遍

##### 分类

> - fmt.P$( )		//将数据输出到控制台
> - fmt.Fp$( )	  //将数据输出到**io.Write**接口的实现者
> - fmt.Sp$( )	   //将数据输出到string()

##### 底层原理

`源码`

```go
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrint(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
```

可以看到我们讲格式化好的字节数组输入到io.Writer中，再由io.Writer的实现者来写入，平时我们比较常用的由stdOut也就是控制台的写入实现者。

`源码`

```go
func Sprint(a ...interface{}) string {
	p := newPrinter()
	p.doPrint(a)
	s := string(p.buf)
	p.free()
	return s
}
```

可以看到这里我们将参数传进去之后**p := newPrinter()，p.doPrint(a)**将参数转换位字节数组，最后由**string()**来转换成string类型返回。



## fmt.P$👨‍✈️

P开头的一般指控制台输出

> - fmt.Print( )	//将数据输出到控制台
> - fmt.Printf( )   //将数据格式化并且输出到控制台。
> - fmt.Println( ) //将数据输出到控制台并且换行。

##### 底层原理

`源码`

```go
func Print(a ...interface{}) (n int, err error) {
	return Fprint(os.Stdout, a...)
}
```

可以看到Print函数将数据通过Fprint转换成byte数组输入到io.Stdout中，Stdout的write方法负责讲字节数组标准写入到控制台中，这就是我们平时使用的控制台输出的基本实现原理。

### fmt.Printf格式化输出🧔

##### 占位符

```go
func main(){
	fmt.Printf("%%")
	fmt.Println()
	fmt.Println("单纯的输出百分号")

	fmt.Printf("%t",true)
	fmt.Println()
	fmt.Println("单纯的输出真假值（true/false）")

	fmt.Printf("%v","string")
	fmt.Println()
	fmt.Println("原格式输出")
	fmt.Printf("%T","string")
	fmt.Println()
	fmt.Println("打印数据类型")

	fmt.Printf("%d",12)
	fmt.Println()
	fmt.Println("十进制方法表示，只能传递int")
	fmt.Printf("%b",12)
	fmt.Println()
	fmt.Println("二进制方法表示，只能传递int")

	fmt.Printf("%q","string")
	fmt.Println()
	fmt.Println("双引号围绕的字符串，由Go语法安全地转义")

	fmt.Printf("%s", []byte("Go语言中文网"))
	fmt.Println()
	fmt.Println("输出字符串表示（string类型或[]byte)")

	fmt.Printf("%c", 0x4E2D)
	fmt.Println()
	fmt.Println("相应Unicode码点所表示的字符")
}
```

##### 格式化错误

如果给占位符提供了无效的实参（例如将一个字符串提供给 %d），所生成的字符串会包含该问题的描述，如下例所示：

```bash
    类型错误或占位符未知：%!verb(type=value)
        Printf("%d", hi):          %!d(string=hi)
    实参太多：%!(EXTRA type=value)
        Printf("hi", "guys"):      hi%!(EXTRA string=guys)
    实参太少： %!verb(MISSING)
        Printf("hi%d"):            hi %!d(MISSING)
    宽度或精度不是int类型: %!(BADWIDTH) 或 %!(BADPREC)
        Printf("%*s", 4.5, "hi"):  %!(BADWIDTH)hi
        Printf("%.*s", 4.5, "hi"): %!(BADPREC)hi
    所有错误都始于“%!”，有时紧跟着单个字符（占位符），并以小括号括住的描述结尾。
```



## fmt.Sp$👨‍🎨

Sp开头的一般指控制台输出

> - fmt.Sprint( )	//将数据转化为字符串。
> - fmt.Sprintf( )   //将数据格式化并且转化为字符串。
> - fmt.Sprintln( ) //将数据转化为字符串并且添加换行。

```go
package main

import "fmt"

type lion struct {
	age int
	name string
}

func (l lion) String() string {
	return fmt.Sprint("狮子名叫",l.name,"，今年",l.age,"岁了。")
}

func main(){
    xb := lion{name:"xinba",age:7}
	fmt.Print(xb)
	fmt.Printf("%T",fmt.Sprint("狮子名叫","，今年","岁了。"))
}
```

```go
狮子名叫xinba，今年7岁了。
string
```



## fmt.Fp$👩‍🏫

Sp开头的一般指控制台输出

> - fmt.Fprint( )	//将数据输出到wtiter接口的实现者。
> - fmt.Fprintf( )   //将数据格式化并且输出到wtiter接口的实现者。
> - fmt.Fprintln( ) //将数据输出到wtiter接口的实现者并且添加换行。

`源码`

```go
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrint(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
```

可以看到我们讲格式化好的字节数组输入到io.Writer中，再由io.Writer的实现者来写入，平时我们比较常用的由stdOut也就是控制台的写入实现者。



## Stringer 接口

Stringer接口的定义如下：

```go
    type Stringer interface {
        String() string
    }
```

根据 Go 语言中实现接口的定义，一个类型只要有 `String() string` 方法，我们就说它实现了 Stringer 接口。而在本节开始已经说到，如果格式化输出某种类型的值，只要它实现了 String() 方法，那么会调用 String() 方法进行处理。

```go
type lion struct {
	age int
	name string
}

func (l lion) String() string {
	return fmt.Sprint("狮子名叫",l.name,"，今年",l.age,"岁了。")
}

func main(){
    xb := lion{name:"狮子王",age:2}
	fmt.Print(xb)
	fmt.Printf("%T",fmt.Sprint("狮子名叫","，今年","岁了。"))
}
```

```go
狮子名叫xinba，今年7岁了。
string
```

