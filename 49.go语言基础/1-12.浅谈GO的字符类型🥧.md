# 浅谈GO的字符类型🥧

### 前言🥙

> 视作常识我们知道计算机表示字符的方式时unicode编码，是一个超大的字符集，纯递增对应关系，但是没法储存，表示单一字符需要的容量过大，而utf-8就是一种能实现储存unicode的编码方式，在utf-8中一个中文字符占两到三个字节来表示一个unicode编码，而英文则占一个字节。



### string类型里存的是什么？🍮

> string里面其实存的是你输入字符串的unicode表示码（utf-8/gb...）。



### 获取string中的一个字符💼

```go
string([]rune(string)[i])
```



### 字符型和int型相加减🏐

我们知道go语言的字符型里面其实是一个 `int32`

```go
type rune = int32
```

所以说字符型可以和int型相加。

```go
string('A'+idx)
```



### range遍历问题？🥠

究其原因还是要说到range遍历还有len()的返回值，go语言中range遍历或者是len()**（len(string)返回的是字节数）**常规遍历，遍历的都是字节，这就会出现一个很严重的问题，遍历时没法打印我们想要的中文字符串中的字符。

##### range遍历string问题

首先：range的使用非常简单，对于遍历array，*array，string它返回两个值分别是数据的索引和值，遍历map时返回的两个值分别是key和value，遍历channel时，则只有一个返回数据。各种类型的返回值参考下表：

![1574751815522](F:\我的笔记\image\1574751815522.png)

直接range遍历字符串，这样输出我们遍历的还是字节，对于字符串来说也就是他的utf-8编码（也可能是别的unicode表示码），而因为你遍历的是字符串对照上表，range的返回值是rune，但是你遍历的是字节呀，所以程序会自动将字节组成unicode编码，然后输出一个rune（用int表示）。

```go
package main

import (
	"fmt"
)

func main() {
	var str string = "chen"
	for i, b := range str {
		fmt.Printf("(%d %X)", i, b)
				fmt.Println(b)
	}
}

(0 63)99
(1 68)104
(2 65)101
(3 6E)110
(4 827E)33406
(7 8389)33673
```



##### range遍历btye[]

> 将string类型强制转换位byte数组，这个时候我们会将字符串里面村的utf-8表示码拆成byte数组。

```go
package main

import (
	"fmt"
)

func main() {
	for i, b := range []byte(str) {
		fmt.Printf("(%d %X)", i, b)
		fmt.Println(b)
		//utf-8编码
	}
	fmt.Println("遍历utf-8编码")
}

(0 63)99
(1 68)104
(2 65)101
(3 6E)110
(4 E8)232
(5 89)137
(6 BE)190
(7 E8)232
(8 8E)142
(9 89)137
```



### 怎么解决🍰

只要我们解决了range遍历的返回值或者len()的返回值，那么这个这个问题不久迎刃而解了么，所以我们只需要把string强制类型转换成rune数组就可以啦。

```go
package main

import (
	"fmt"
)

func main() {
	for i, ch := range []rune(s) {
		fmt.Printf("(%d %c) ", i, ch)
	}
}
```

