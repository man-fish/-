# 包和封装👨‍🏫

## 封装结构体☢

> - 名字使用驼峰命名法
> - 首字母大写：public，是真的共有，不然就报错。
> - 首字母小写：private，是真的私有，不然就报错。



## how a go project run？☣

先想一想结构体，一个结构体有私有成员和公有成员，有私有方法和公有方法，可以实例化，那么他实现的功能和类没有关系，但是还不足够，还需要模块化来产生联系。



## 包💢

#### 包的规则💥

> - 每个目录有且只有一个包，包不一定是目录名。
> - 一个包下可以有多个结构体。
> - 为结构定义的方法必须定义在同一个包内但是可以是不同的文件，声明接收者来和包产生关联。
> - mian包包含可执行入口，一个目录只能有一个入口函数（main），每个目录又只能有一个包，所以main入口函数必须单独一个包。

![](F:\我的笔记\image\pakg.png)

#### 引用包💔

> 包的引用我们可以写绝对路径，也可以从网上引用（github），还可以使用相对路径和环境变量下的包名。



## 继承🖤

> 用于扩充系统重写引用包的方法

#### 使用组合实现继承💖

```go
package main
import ".."
import "fmt"

type myTreeNode struct{
	node *tree.TreeNode
}

func (myNode *myTreeNode) postOrderTrverse (){
	if myNode == nil || myNode.node == nil {
		return 		
	}
	left := myTreeNode{myNode.node.Left}
	right := myTreeNode{myNode.node.Right}
	left.postOrderTrverse()
	right.postOrderTrverse()
	myNode.node.Print()
}

func main() {
	var root tree.TreeNode
	root = tree.TreeNode{Value: 3}
	myRoot := myTreeNode{&root}
	myRoot.postOrderTrverse()
}
```

#### 类型定义实现继承💕

> 比如这里我们重写数组实现队列

```go
package queue

type Queue []int

func (q *Queue) Push(v int){
	*q = append(*q, v)
}

func (q *Queue) Pop() int {
	head := (*q)[0]
	*q = (*q)[1:]
	return head
}

func (q *Queue) IsEmpty() bool {
	return len(*q) == 0
}
```

```go
package main

import (
	".."
	"fmt"
)

func main() {
	var a []int= []int{1}
	fmt.Print(a)
	var q queue.Queue= queue.Queue{1}
	q.Push(2)
	q.Push(3)
	fmt.Print(q.Pop())
	fmt.Print(q.Pop())
	fmt.Print(q.IsEmpty())
	fmt.Print(q.Pop())
	fmt.Print(q.IsEmpty())
}
```

