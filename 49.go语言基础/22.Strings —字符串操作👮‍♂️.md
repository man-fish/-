# Strings 字符串操作👮‍♂️

## 基础函数🧚‍♂️

### 是否存在某个子串Contains👨‍✈️

有三个函数做这件事：

```go
// 子串 substr 在 s 中，返回 true
func Contains(s, substr string) bool
// chars 中任何一个 Unicode 代码点在 s 中，返回 true
func ContainsAny(s, chars string) bool
```

这里对 ContainsAny 函数进行一下说明，看如下例子：

```go
var str string = "innoweb.com我"
fmt.Println(strings.Contains(str,"inno"))
fmt.Println(strings.Contains(str,"l n"))
```

```go
fmt.Println(strings.ContainsAny("team", "i"))			//博阿寒i
fmt.Println(strings.ContainsAny("failure", "u & i"))	//包含u或者i
fmt.Println(strings.ContainsAny("in failure", "s g"))	//包含s或者 或者g
fmt.Println(strings.ContainsAny("foo", ""))			
fmt.Println(strings.ContainsAny("", ""))
```

输出：

```go
true
false
```

```bash
false
true
true
false
false
```



### 字符串比较Compare👰

>  Compare 函数，用于比较两个字符串的大小:
>
> 如果两个字符串相等，返回为 0。如果 a 小于 b ，返回 -1 ，反之返回 1 。不推荐使用这个函数，直接使用 == != > < >= <= 等一系列运算符更加直观。

```go
func Compare(a, b string) int 
//   EqualFold 函数，计算 s 与 t 忽略字母大小写后是否相等。
func EqualFold(s, t string) bool
```

```go
fmt.Println(strings.Compare(str,str2))
// Compare 函数，用于比较两个字符串的大小，如果两个字符串相等，返回为 0。如果 a 小于 b ，返回 -1 ，反之返回 1 。
fmt.Println(strings.EqualFold("GO", "go"))
// EqualFold 函数，计算 s 与 t 忽略字母大小写后是否相等。
```



###  子串出现次数 Count👩‍🏭

在数据结构与算法中，可能会讲解以下字符串匹配算法：

- 朴素匹配算法
- KMP 算法
- Rabin-Karp 算法
- Boyer-Moore 算法

还有其他的算法，这里不一一列举，感兴趣的可以网上搜一下。

在 Go 中，查找子串出现次数即字符串模式匹配，实现的是 Rabin-Karp 算法。Count 函数的签名如下：

```go
func Count(s, sep string) int
```

在 Count 的实现中，处理了几种特殊情况，属于字符匹配预处理的一部分。这里要特别说明一下的是当 sep 为空时，Count 的返回值是：utf8.RuneCountInString(s) + 1

```go
fmt.Println(strings.Count("cheeseeee", "ee"))
fmt.Println(strings.Count("fivevev", "vev"))
// Count 是计算子串在字符串中出现的无重叠的次数
```

输出：

```bash
3
1
```



### 字符串重复几次生成Repeat👨‍⚖️

函数签名如下：

```go
func Repeat(s string, count int) string
```

将 s 重复 count 次，如果 count 为负数或返回值长度 len(s)*count 超出 string 上限会导致 panic，这个函数使用很简单：

```go
fmt.Println("ba" + strings.Repeat("na", 2))
```

输出结果：

```bash
banana
```



### 字符串切割Split 和 SplitAfter🧙‍♂️

这四个函数都是通过 **sep** 进行分割，返回[]string。如果 **sep** 为空，相当于**分成一个个的 UTF-8 字符**，如 `Split("abc","")`，得到的是**[a b c]**。

```go
func Split(s, sep string) []string 
func SplitAfter(s, sep string) []string 
```

那么，Split 和 SplitAfter 有啥区别呢？通过这两句代码的结果就知道它们的区别了：

```go
fmt.Printf("%q\n", strings.Split("foo,bar,baz", ","))
fmt.Printf("%q\n", strings.SplitAfter("foo,bar,baz", ","))
```

输出：

```bash
["foo" "bar" "baz"]
["foo," "bar," "baz"]
```

也就是说，Split 会将 s 中的 sep 去掉，而 SplitAfter 会保留 sep。



### 字符串组合 JOIN 操作👨‍🔬

将字符串数组（或 slice）连接起来可以通过 Join 实现，函数签名如下：

```go
func Join(a []string, sep string) string
```

```go
fmt.Println(strings.Join(strings.Split("a,b,c,d,e",","),""))
//abcde
```



### 大小写转换ToUpper🧛‍♂️

```go
func ToLower(s string) string
func ToUpper(s string) string
```

大小写转换包含了 4 个相关函数，ToLower,ToUpper 用于大小写转换。ToLowerSpecial,ToUpperSpecial 可以转换特殊字符的大小写。 举个例子：

```go
fmt.Println(strings.ToLower("HELLO WORLD"))
fmt.Println(strings.ToLower("Ā Á Ǎ À"))
fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, "壹"))
fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, "HELLO WORLD"))
fmt.Println(strings.ToLower("Önnek İş"))
fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, "Önnek İş"))

fmt.Println(strings.ToUpper("hello world"))
fmt.Println(strings.ToUpper("ā á ǎ à"))
fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, "一"))
fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, "hello world"))
fmt.Println(strings.ToUpper("örnek iş"))
fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, "örnek iş"))
```

输出结果:

```bash
hello world
ā á ǎ à
壹
hello world
önnek iş
önnek iş
HELLO WORLD
Ā Á Ǎ À       // 汉字拼音有效
一           //  汉字无效
HELLO WORLD
ÖRNEK IŞ
ÖRNEK İŞ    // 有细微差别
```



### 修剪Trim👨‍🎤

```go
// 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉
func Trim(s string, cutset string) string
// 将 s 左侧的匹配 cutset 中的任一字符的字符去掉
func TrimLeft(s string, cutset string) string
// 将 s 右侧的匹配 cutset 中的任一字符的字符去掉
func TrimRight(s string, cutset string) string
// 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。
func TrimPrefix(s, prefix string) string
// 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。
```

包含了 9 个相关函数用于修剪字符串。

> 举个例子：

```go
var a string = "!!@@$$  "
fmt.Println(strings.Trim(a,"! "))
//@@$$
var a string = "!!@@$$  "
fmt.Println(strings.Trim(a,"! "))
fmt.Println(strings.TrimLeft(a,"!@"))
fmt.Println(strings.TrimRight(a,"$"))
fmt.Println(strings.TrimPrefix(a,"$$"))
//@@$$
//$$  
//!!@@$$空格空格
//!!@@$$空格空格  
```



### 字符串是否有某个前缀或后缀🧜‍♂️

这两个函数比较简单，源码如下：

```go
// s 中是否以 prefix 开始
func HasPrefix(s, prefix string) bool {
  return len(s) >= len(prefix) && s[0:len(prefix)] == prefix
}
// s 中是否以 suffix 结尾
func HasSuffix(s, suffix string) bool {
  return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
}
```

如果 prefix 或 suffix 为 "" , 返回值总是 true。

示例：

```go
fmt.Println(strings.HasPrefix("Gopher", "Go"))
fmt.Println(strings.HasPrefix("Gopher", "C"))
fmt.Println(strings.HasPrefix("Gopher", ""))
fmt.Println(strings.HasSuffix("Amigo", "go"))
fmt.Println(strings.HasSuffix("Amigo", "Ami"))
fmt.Println(strings.HasSuffix("Amigo", ""))
```

输出结果：

```bash
true
false
true
true
false
true
```



### 子串在字符串中出现的位置Index💂‍♂️

有一序列函数与该功能有关：

```go
// 在 s 中查找 sep 的第一次出现，返回第一次出现的索引
func Index(s, sep string) int
// 在 s 中查找字节 c 的第一次出现，返回第一次出现的索引
func IndexByte(s string, c byte) int
// chars 中任何一个 Unicode 代码点在 s 中首次出现的位置
func IndexAny(s, chars string) int
// 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true
func IndexFunc(s string, f func(rune) bool) int
// Unicode 代码点 r 在 s 中第一次出现的位置
func IndexRune(s string, r rune) int

// 有三个对应的查找最后一次出现的位置
func LastIndex(s, sep string) int
func LastIndexByte(s string, c byte) int
func LastIndexAny(s, chars string) int
func LastIndexFunc(s string, f func(rune) bool) int
```

在 2.1.1 小节提到过，Contain 相关的函数内部调用的是响应的 Index 函数。

这一序列函数，只举 IndexFunc 的例子：

```go
han := func(c rune) bool {
    return unicode.Is(unicode.Han, c) // 汉字
}
fmt.Println(strings.IndexFunc("Hello, world", han))
fmt.Println(strings.IndexFunc("Hello, 世界", han))
```

输出：

```bash
-1
7
```



## strings包的Reader接口👩‍🚒

解读之前先来理解一下reader接口和writer接口，想象一下读和写的过程。

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}
```

> 可以看到这个**Read**函数接受一个字节数组，返回一个**int n**和**err**，**int n**返回的时读取字节数，**err**返回的一般是**EOF（END-OF-FILE）**或者是**NIL**，当我们没完全读完文件时返回的就是**NIL**，否则就是**EOF**。读出来的字符会直接读到字节数组**p**中，因为是切片数组所以会对原数组内容造成影响，不需要返回并且接受。

接下来我们来看一下这个函数，其功能大概是对数组进行输入，并且根据n判断是否读到了值返回字节数组。

```go
func ReadFrom(reader io.Reader, num int) ([]byte, error) {
	p := make([]byte, num)
	n, err := reader.Read(p)
	fmt.Println(n)
	if n > 0 {
		return p[:n], nil
	}
	return p, err
}
```

我们调用strings下的NewReader方法返回一个符合io.Reader的结构体，然后我们对其进行三次读取。

```go
func main(){
	s := strings.NewReader("123")
	data1, err := ReadFrom(s,1)
	data2, err := ReadFrom(s,2)
	data3, err := ReadFrom(s,3)
	fmt.Println(data1,err)
	fmt.Println(data2,err)
	fmt.Println(data3,err)
}
```

分析读取结果，我们发现读取是记录状态的，读不到东西的时候返回了endOfFile。

```go
1 <nil>
2 <nil>
0 EOF
[49] EOF
[50 51] EOF
[0 0 0] EOF
```

那么我们来看一下**strings.NewReader("123")**返回了怎么样的一个实现者。

```go
func NewReader(s string) *Reader { return &Reader{s, 0, -1} }
type Reader struct {
	s        string
	i        int64 // current reading index
	prevRune int   // index of previous rune; or < 0
}
```

> 这里面string s记录实际的内容，i表示已经读到的位置，prevRune表示上一个。

### Read👼

接下来我们看看他的read方法

```go
func (r *Reader) Read(b []byte) (n int, err error) {
	if r.i >= int64(len(r.s)) {
		return 0, io.EOF
	}
	r.prevRune = -1
	n = copy(b, r.s[r.i:])
	r.i += int64(n)
	return
}
```

> 如果说**r.i >= int64(len(r.s)）**那么字符串已经被读完了，返回**EOF**，否则拷贝字符串内容到btye数组中，然后后移r.i拷贝数组的长度，返回实际读取字符串的长度和nil（没有读取错误）。这就是一个read的过程。

### ReadAt🧔

然后再看看ReadAt方法

```go
func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) {
	if off < 0 {
		return 0, errors.New("strings.Reader.ReadAt: negative offset")
	}
	if off >= int64(len(r.s)) {
		return 0, io.EOF
	}
	n = copy(b, r.s[off:])
	if n < len(b) {
		err = io.EOF
	}
	return
}
```

> 先判断偏移量是否越界，然后拷贝数组，如果拷贝没有实际拷贝效果就抛出EOF，否则返回拷贝字节数和null，这个就不需要考虑上一次的读取位置了，每一次都是随机的。

