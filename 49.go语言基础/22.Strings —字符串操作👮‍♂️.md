# Strings 字符串操作👮‍♂️

### strings包的Reader接口

解读之前先来理解一下reader接口和writer接口，想象一下读和写的过程。

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}
```

> 可以看到这个**Read**函数接受一个字节数组，返回一个**int n**和**err**，**int n**返回的时读取字节数，**err**返回的一般是**EOF（END-OF-FILE）**或者是**NIL**，当我们没完全读完文件时返回的就是**NIL**，否则就是**EOF**。读出来的字符会直接读到字节数组**p**中，因为是切片数组所以会对原数组内容造成影响，不需要返回并且接受。

接下来我们来看一下这个函数，其功能大概是对数组进行输入，并且根据n判断是否读到了值返回字节数组。

```go
func ReadFrom(reader io.Reader, num int) ([]byte, error) {
	p := make([]byte, num)
	n, err := reader.Read(p)
	fmt.Println(n)
	if n > 0 {
		return p[:n], nil
	}
	return p, err
}
```

我们调用strings下的NewReader方法返回一个符合io.Reader的结构体，然后我们对其进行三次读取。

```go
func main(){
	s := strings.NewReader("123")
	data1, err := ReadFrom(s,1)
	data2, err := ReadFrom(s,2)
	data3, err := ReadFrom(s,3)
	fmt.Println(data1,err)
	fmt.Println(data2,err)
	fmt.Println(data3,err)
}
```

分析读取结果，我们发现读取是记录状态的，读不到东西的时候返回了endOfFile。

```go
1 <nil>
2 <nil>
0 EOF
[49] EOF
[50 51] EOF
[0 0 0] EOF
```

那么我们来看一下**strings.NewReader("123")**返回了怎么样的一个实现者。

```go
func NewReader(s string) *Reader { return &Reader{s, 0, -1} }
type Reader struct {
	s        string
	i        int64 // current reading index
	prevRune int   // index of previous rune; or < 0
}
```

> 这里面string s记录实际的内容，i表示已经读到的位置，prevRune表示上一个。

##### Read

接下来我们看看他的read方法

```go
func (r *Reader) Read(b []byte) (n int, err error) {
	if r.i >= int64(len(r.s)) {
		return 0, io.EOF
	}
	r.prevRune = -1
	n = copy(b, r.s[r.i:])
	r.i += int64(n)
	return
}
```

> 如果说**r.i >= int64(len(r.s)）**那么字符串已经被读完了，返回**EOF**，否则拷贝字符串内容到btye数组中，然后后移r.i拷贝数组的长度，返回实际读取字符串的长度和nil（没有读取错误）。这就是一个read的过程。

##### ReadAt

然后再看看ReadAt方法

```go
func (r *Reader) ReadAt(b []byte, off int64) (n int, err error) {
	if off < 0 {
		return 0, errors.New("strings.Reader.ReadAt: negative offset")
	}
	if off >= int64(len(r.s)) {
		return 0, io.EOF
	}
	n = copy(b, r.s[off:])
	if n < len(b) {
		err = io.EOF
	}
	return
}
```

> 先判断偏移量是否越界，然后拷贝数组，如果拷贝没有实际拷贝效果就抛出EOF，否则返回拷贝字节数和null，这个就不需要考虑上一次的读取位置了，每一次都是随机的。

