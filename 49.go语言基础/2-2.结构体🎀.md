# 结构体🎀

> 结构体在c和c++中被看成是数据的集合但是不能声明函数，在go中我们使用结构体和接收者函数来实现类的功能，但是在go中没有继承和多态，只有封装，使用接口来实现继承和多态。



## 结构体操作🎁

#### 创建结构体🎠

> 定义结构体，并且实例化结构体。

使用**tree{ }**或者是**new(treeNode）**都能实例化一个结构体，当然还有切片创建。

```go
package main
import "fmt"

type treeNode struct {
	//声明结构体
	value       int
	left, right *treeNode
}

func(){
	var root treeNode
	root = treeNode{value: 3}
    // 创建方法一		3
	root.left = &treeNode{5, nil, nil}
	// 创建方法二	5	3
	root.right = &treeNode{}
	// 创建方法三
	root.right.left = new(treeNode)
	// 创建方法四	5	3	0	0
	nodes := []treeNode{
		{value: 3},
		{},
		{6, nil, &root}}
		// 创建方法五
}
```

#### 匿名结构体🍥

在定义一些临时数据结构等场景下还可以使用匿名结构体。

```go
package main
     
import (
    "fmt"
)
     
func main() {
    var user struct{Name string; Age int}
    user.Name = "小王子"
    user.Age = 18
    fmt.Printf("%#v\n", user)
}
```

#### 工场式创建结构体🎪

> 自定义工厂函数,类似其他语言中的构造函数。

我们可以看到我们返回了一个局部变量，这是因为go语言可以返回局部变量地址,如果调用之后返回的局部变量的地址被别人使用就不会被垃圾回收,否则反之。

```go
package main
import "fmt"

type treeNode struct {
	value       int
	left, right *treeNode
}

func createNode(value int) *treeNode /**返回一个指针类型*/ {
	return &treeNode{value: value}
}

func main() {
	var root treeNode
	root = treeNode{value: 3}
	root.left = &treeNode{5, nil, nil}
	root.left.right = createNode(2)
	// 工厂式创建		
}
```

#### 使用结构体实例属性🎫

不同于c，c++不管是值类型还是指针类型都是用 **. ** 来调用，不使用 **->** 。

```go
package main
import "fmt"

type treeNode struct {
	value       int
	left, right *treeNode
}

func main() {
	root.left.right
}
```

#### 遍历结构体🤑

没错就是数据结构中的先中后遍历，下面是中序遍历。

```go
package main
import "fmt"

type treeNode struct {
	value       int
	left, right *treeNode
}

func (node treeNode) trverse() {
	if(node == nill){
		return
	}
	node.left.trverse()
	node.print()//定义在下面了。
	node.right.trverse()
}

func main() {}
```



## 接收者函数🎡

#### 基础定义方式🎢

> go语言的接收者函数和普通函数是一样的（写在前面也没有this指向），我们通常用来给构体定义方法。

```go
package main
import "fmt"

type treeNode struct {
	value       int
	left, right *treeNode
}

func setValue(node treeNode, value int) {
	node.value = value
}
//==========================================================================
func (node treeNode) setValue(value int) {
	node.value = value
}

func main() {
	var root treeNode
	root = treeNode{value: 3}
	root.left = new(treeNode)
		
}
```

#### 给构造体定义方法🎃

##### 定义值接收者方法🥡

```go
package main
import "fmt"

type treeNode struct {
	value       int
	left, right *treeNode
}

func (node treeNode) /**接收者*/ print() {
	//定义接收者函数,相当于其他语言对象中的this
	//JS Person.prototype.print = function(){}
	fmt.Println(node.value)
}
//go语言结构体没有this指针，所以要给结构体定义方法就需要定义结构接收者方法。

func main() {
	var root treeNode
	root = treeNode{value: 3}
    root.print()
}
```

##### 定义指针接收者方法🥧

> 想要个构造体定义方法我们很明显能发现就上面说的没有this就没法修改结构体实例的属性，（普通变量传进去的是值类型），所以我们干脆以指针作为接收者（传进去的是拷贝）。

```go
package main
import "fmt"

type treeNode struct {
	//声明结构体
	value       int
	left, right *treeNode
}

func (node *treeNode) setValue(value int) {
	node.value = value
}

func main() {
	var root treeNode
	root = treeNode{value: 3}
    &root.setValue(7)
}
```

##### 接收者函数会自动识别接受类型🍯

> 如果接收者函数要的是指针，而调用者是值，那么函数自动取地址，反之亦然。

```go
package main
import "fmt"

type treeNode struct {
	value       int
	left, right *treeNode
}

func (node treeNode) print() {
	fmt.Println(node.value)
}

func (node *treeNode) setValue(value int) {
	node.value = value
}
//接受者非常灵活，不管是定义的是指针接受者还是值接收者，传入时既可以是指针又可以是值

func main() {
	var root treeNode
	root = treeNode{value: 3}
    &root.setValue(7)
    &root.print()
}
```

##### 可以传入nil🍫

> 可以传入nil，但是不能使用空指针nil继续打点调用（nil.left），这点go设计的非常完美，不像java一样爆指针异常，类似js的原则。

```go
package main
import "fmt"

type treeNode struct {
	value       int
	left, right *treeNode
}

func (node *treeNode) setValue(value int) {
	if(node == nill){
		return
	}
	node.value = value
}

func main() {
	var root treeNode
	root = treeNode{value: 3}
    &root.setValue(7)
    &root.print()
}
```



## 结构体嵌套🍜

> 一个结构体中可以嵌套包含另一个结构体或结构体指针。

#### 创建一个嵌套🥟

```go
//Address 地址结构体
type Address struct {
	Province string
	City     string
}

//User 用户结构体
type User struct {
	Name    string
	Gender  string
	Address Address
}

func main() {
	user1 := User{
		Name:   "小王子",
		Gender: "男",
		Address: Address{
			Province: "山东",
			City:     "威海",
		},
	}
	fmt.Printf("user1=%#v\n", user1)
    //user1=main.User{Name:"小王子", Gender:"男", Address:main.Address{Province:"山东", City:"威海"}}
}
```

#### 嵌套匿名结构体🍨

当访问结构体成员时会先在结构体中查找该字段，找不到再去匿名结构体中查找。

```go
//Address 地址结构体
type Address struct {
	Province string
	City     string
}

//User 用户结构体
type User struct {
	Name    string
	Gender  string
	Address //匿名结构体
}

func main() {
	var user2 User
	user2.Name = "小王子"
	user2.Gender = "男"
	user2.Address.Province = "山东"    //通过匿名结构体.字段名访问
	user2.City = "威海"                //直接访问匿名结构体的字段名
	fmt.Printf("user2=%#v\n", user2) 
    //user2=main.User{Name:"小王子", Gender:"男", Address:main.Address{Province:"山东", City:"威海"}}
}
```

#### 嵌套结构体的字段名冲突☕

嵌套结构体内部可能存在相同的字段名。这个时候为了避免歧义需要指定具体的内嵌结构体的字段。

```go
//Address 地址结构体
type Address struct {
	Province   string
	City       string
	CreateTime string
}

//Email 邮箱结构体
type Email struct {
	Account    string
	CreateTime string
}

//User 用户结构体
type User struct {
	Name   string
	Gender string
	Address
	Email
}

func main() {
	var user3 User
	user3.Name = "沙河娜扎"
	user3.Gender = "男"
	// user3.CreateTime = "2019" //ambiguous selector user3.CreateTime
	user3.Address.CreateTime = "2000" //指定Address结构体中的CreateTime
	user3.Email.CreateTime = "2000"   //指定Email结构体中的CreateTime
}
```



## 结构体的“继承”🍹

Go语言中使用结构体也可以实现其他编程语言中面向对象的继承，**继承是靠结构体匿名嵌套实现的，我们一起来看一看。**

```go
//Animal 动物
type Animal struct {
	name string
}

func (a *Animal) move() {
	fmt.Printf("%s会动！\n", a.name)
}

//Dog 狗
type Dog struct {
	Feet    int8
	*Animal //通过嵌套匿名结构体实现继承
}

func (d *Dog) wang() {
	fmt.Printf("%s会汪汪汪~\n", d.name)
}

func main() {
	d1 := &Dog{
		Feet: 4,
		Animal: &Animal{ //注意嵌套的是结构体指针
			name: "乐乐",
		},
	}
	d1.wang() //乐乐会汪汪汪~
	d1.move() //乐乐会动！
}
```