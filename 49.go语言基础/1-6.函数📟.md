# 函数📟

### 参数和返回值🥞

##### 不确定返回值名称🚤

```go
package main

import (
	"fmt"
)

func div(a, b int) (int, int) {
	return a / b, a % b
}

func main(){
    r,m := div(2,5)
    fmt.Println(r,m)
}
```

##### 确定返回值名称（推荐）🥨

```go
package main

import (
	"fmt"
)

func div2(a, b int) (q, r int) {
	return a / b, a % b
}

func main() {
	q, r := div2(1, 2)
	fmt.Println(q, r)
}
```

##### 怪b写法（不推荐）+如何不接受某个返回值👵

> 首先函数返回的两个返回值在go里我们必须全部接受并且使用，那样问题就很明显了。
>
> 不过处理方案也很简单，_在go里面是占位符。

```go
package main

import (
	"fmt"
	"math"
	"reflect"
	"runtime"
)

func div3(a, b int) (z, x int) {
	//不推荐
	z = a / b
	x = a % b
	return
}

func main() {
	z, _ := div3(4, 5)
}
```

> 默认返回值

```go
package main

import "fmt"

func con() (z []int){
	return
}

func main (){
	fmt.Printf("%T",con())
	fmt.Println(con())
}
```



##### 变长参数🎐

```go
func sum(numbers ...int) int {
	s := 0
	for i := range numbers {
		s += numbers[i]
	}
	return s
}

func main() {
	fmt.Println(sum(1, 2, 1, 2))
}
```

##### 函数作为参数🎋

```go
package main

import (
	"fmt"
	"math"
	"reflect"
	"runtime"
)

func apply(op func(int, int) int, a, b int) int {
	p := reflect.ValueOf(op).Pointer()
	opName := runtime.FuncForPC(p).Name()
	fmt.Printf("Calling function %s with args"+"(%d,%d)", opName, a, b)
	return op(a, b)
}

func pow(a, b int) int {
	return int(math.Pow(float64(a), float64(b)))
}

func main() {
	fmt.Println(apply(pow, 3, 4))
}
```