# GO的错误处理🥑

Go语言追求简洁优雅，所以，Go语言不支持传统的 try…catch…finally 这种异常，因为Go语言的设计者们认为，将异常与控制结构混在一起会很容易使得代码变得混乱。因为开发者很容易滥用异常，甚至一个小小的错误都抛出一个异常。在Go语言中，使用多值返回来返回错误。不要用异常代替错误，更不要用来控制流程。在极个别的情况下，也就是说，遇到真正的异常的情况下（比如除数为0了）。才使用Go中引入的Exception处理：defer, panic, recover。

## panic

```go
func panic(v interface{})
```

panic 英文原意：n. 恐慌，惊慌；大恐慌  adj. 恐慌的；没有理由的  vt. 使恐慌  vi. 十分惊慌

panic 是用来表示非常严重的不可恢复的错误的。在Go语言中这是一个内置函数，接收一个interface{}类型的值（也就是任何值了）作为参数。panic的作用就像我们平常接触的异常。不过Go可没有try…catch，所以，panic一般会导致程序挂掉（除非recover）。所以，Go语言中的异常，那真的是异常了。你可以试试，调用panic看看，程序立马挂掉，然后Go运行时会打印出调用栈。
但是，关键的一点是，即使函数执行的时候panic了，函数不往下走了，运行时并不是立刻向上传递panic，而是到defer那，等defer的东西都跑完了，panic再向上传递。所以这时候 defer 有点类似 try-catch-finally 中的 finally。panic就是这么简单。抛出个真正意义上的异常。

## recover

```go
func recover() interface{}	//panic中传递的空接口类型。
```

recover 英文原意： vt. 恢复；弥补；重新获得  vi. 恢复；胜诉；重新得球  n. 还原至预备姿势

上面说到，panic的函数并不会立刻返回，而是先defer，再返回。这时候（defer的时候），如果有办法将panic捕获到，并阻止panic传递，那就异常的处理机制就完善了。

Go语言提供了recover内置函数，前面提到，一旦panic，逻辑就会走到defer那，那我们就在defer那等着，调用recover函数将会捕获到当前的panic（如果有的话），被捕获到的panic就不会向上传递了，于是，世界恢复了和平。你可以干你想干的事情了。

不过要注意的是，recover之后，逻辑并不会恢复到panic那个点去，函数还是会在defer之后返回。

panic接受任意类型，会转换成字符串输出并且中断执行。

```go
func main() {
    //方法一：
    //采用errors包的New方法 返回一个err的类型
    var err error = errors.New("this is a new error")
    //由于已经实现了error接口的方法 因此可以直接调用对应的方法
    fmt.Println(err.Error())

    //方法二：
    //采用fmt.Errof 将string信息转化为error信息 并返回
    err = fmt.Errorf("%s", "the error test for fmt.Errorf")
    fmt.Println(err.Error())
}
```



# GO的错误类型

`error`接口包含一个函数返回一个`string`类型，通常我们panic时就会打印这个`string`类型。

```go
type error interface {
	Error() string
}
```

## errors

`errors`包给你实现了一个`error`接口。

```go
// Package errors implements functions to manipulate errors.
package errors

// New returns an error that formats as the given text.
func New(text string) error {
    return &errorString{text}
}

// errorString is a trivial implementation of error.
type errorString struct {
    s string
}

func (e *errorString) Error() string {
    return e.s
}
```

#### 使用

```go
func main() {
    //采用errors包的New方法 返回一个err的类型
    var err error = errors.New("this is a new error")
    //由于已经实现了error接口的方法 因此可以直接调用对应的方法
    fmt.Println(err.Error())
}
```



## fmt

采用`fmt.Errorf`方法把`string`类型转化为`error`类型，在这个方法的内部，先调用`fmt`包中的`Sprintf`方法把格式化的输入转化为字符串，在使用 `errors.New` 方法返回`error`类型。

```go
func Errorf(format string, a ...interface{}) error {
    p := newPrinter()
    p.wrapErrs = true
    p.doPrintf(format, a)
    s := string(p.buf)
    var err error
    if p.wrappedErr == nil {
        err = errors.New(s)
    } else {
        err = &wrapError{s, p.wrappedErr}
    }
    p.free()
    return err
}
```

#### 使用

```go
func main() {
    //采用fmt.Errof 将string信息转化为error信息 并返回
    err = fmt.Errorf("%s", "the error test for fmt.Errorf")
    fmt.Println(err.Error())
}
```



## 自定义错误类型

#### 接口

```go
type userError interface {
	error
	Message() string
}
```

#### 实现者

```go
type userError string

func (e userError) Error() string {
	return e.Message()
}

func (e userError) Message() string {
	return string(e)
}
```



## web 全局处理

#### 总入口

```go
package main

import (
	"fmt"
	"go_learning/src/eorrorhandle/staticfIleserver/filelisten"
	"log"
	"net/http"
	"os"
)

type appHandler func(writer http.ResponseWriter,request *http.Request) error
//因为HandleFunc要的函数没有error返回值，所以我们包裹HandleFunc，调用真正的路由函数处理掉他内部的error。

func errWraper(handler appHandler) func(writer http.ResponseWriter,request *http.Request){
	return func(writer http.ResponseWriter, request *http.Request) {
 		defer func() {
 			//防止引用程序内部出错。
 			if r := recover(); r != nil {
 				log.Printf("Panic:%v",r)
 				http.Error(writer,
 					http.StatusText(http.StatusInternalServerError),
 					http.StatusInternalServerError)
			}
		}()
		err := handler(writer,request)
		//实际业务执行语句体
		if err != nil {
            //处理实际路由内部暴露出来的error，类似之前做的koa框架的错误封装,我们已知的错误类型通过内置的定义码处理返回给			  客户端，不知道的类型直接抛出500错误，当然内置的错误类型通常都是不够的，我们可以自己定义错误接口。
			fmt.Println(fmt.Sprintf("Errot handling Request：%s"),err.Error())

			if userErr, ok := err.(userError); ok {
                //调用我们在这里设置的鸭子类型，来处理我们拓展的错误类型。
				http.Error(writer,
					userErr.Message(),
					http.StatusBadRequest)
				return
			}

			code := http.StatusOK
			switch {
			case os.IsNotExist(err):
				code = http.StatusNotFound
			case os.IsPermission(err):
				code = http.StatusForbidden
			default:
				code = http.StatusInternalServerError
			}
			http.Error(
				writer,
				http.StatusText(code),
				code,)
		}
	}
}

type userError interface {
    //调用我们在这里设置的鸭子类型。
	error
	Message() string
}

func main() {
	http.HandleFunc("/",errWraper(filelisten.HandleFileList))
	err := http.ListenAndServe(":8888",nil)
	if err != nil {
		panic (err)
	}
}
```

#### 某路由

在实际路由函数内部我们有错误就抛出来（一层一层的抛出来。）

```go
package handler

import (
	"fmt"
	"io/ioutil"
	"mime"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"
)

type userError string

func (e userError) Error() string {
	return e.Message()
}

func (e userError) Message() string {
	return string(e)
}


const prefix string = "/static/"

func StaticFileHandler(res http.ResponseWriter,req *http.Request) error {
		if strings.Index(req.URL.Path,prefix) != 0 {
			return userError(fmt.Sprintf("Path %v must start with %v",req.URL.Path,prefix))
		}

		filePath := req.URL.Path
		//获取所取路径
		appPath, err := os.Executable()
		// 获得程序路径(application)
		wantedFile := filepath.Join(filepath.Dir(appPath),filePath)
		//拼接为文件路径
		fmt.Println("user visit \n","->",wantedFile)

		fr, err := os.Open(wantedFile)
		if err != nil {
			return err
		}

		defer fr.Close()
		fileContent, err := ioutil.ReadAll(fr)
		if err != nil {
			return err
		}

		SetContentTypeFromExtension(res,path.Ext(filePath))
		//根据文件类型设置请求头。

		_,err = res.Write(fileContent)
		if err != nil {
			return err
		}
		return nil
}

func SetContentTypeFromExtension(w http.ResponseWriter,extension string){
		mimeType := mime.TypeByExtension(extension)
		if mimeType != "" {
			w.Header().Set("Content-Type",mimeType)
		}
}
```

