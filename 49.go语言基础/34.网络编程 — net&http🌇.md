# 网络编程 — net&http🌏

## 发送GET请求📡

### http.Get⛵

使用go语言发送get请求，只需要传入URL参数就行了，要预先写好请求参数。

```go
package main

func main(){
	resp, err := http.Get("http://127.0.0.1:3000/getData")
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
		panic(err)
	}
	fmt.Printf("%T -> %v",body,body)
    //[]uint8 -> [104 101 108 108 111 32 115 101 114 118 101 114 32 114 117 110 32 98 121 32 71 79 32]
	fmt.Println(string(body))
}
```

#### resp.Body

请求返回的响应体，是一个实现了`Reader`接口的数据类型，可以直接使用`ReadAll`读取字节数组内容，读取完一定要关闭。

```go
defer resp.Body.Close()
```

### 添加 query 参数🔌

#### ParseRequestURI

这个函数会返回一个URL结构体，如果传入URL格式不对的话会报错。

###### 源代码

```go
func ParseRequestURI(rawurl string) (*URL, error) {
	url, err := parse(rawurl, true)
	if err != nil {
		return nil, &Error{"parse", rawurl, err}
	}
	return url, nil
}
```

###### URL结构体格式

```go
type URL struct {
	Scheme     string    // no use
	Opaque     string    // no use
	User       *Userinfo // no use
    RawPath    string    // no use
    Fragment   string    // fragment for references, without '#'	no use
    ForceQuery bool      // append a query ('?') even if RawQuery is empty   no use
    //usefull
	Host       string    // host or host:port
	Path       string    // pathname without query
	RawQuery   string    // encoded query values, without '? like 'id=1&love=1
}
```

###### String方法

```go
func (u *URL) String() string
```

###### Query方法

```go
func (u *URL) Query() Values {   v, _ := ParseQuery(u.RawQuery)   return v}
```

> 返回的是一个url.Values可以调用get和set方法

#### url.Values{}

###### 声明

```go
data := url.Values{}
```

> 其实是一个类型别名
>
> - type Values map[string][]string

###### Set方法

```go
func (v Values) Set(key, value string) {
	v[key] = []string{value}
}
```

###### Add方法

```go
func (v Values) Add(key, value string) {
	v[key] = append(v[key], value)
}
```

###### Encode方法

```go
func (v Values) Encode() string
```

###### 实现添加参数

```go
package main

func main(){
	apiUrl := "http://127.0.0.1:8888/getData?"
	u, err := url.ParseRequestURI(apiUrl)
	if err != nil {
		fmt.Printf("parse url requestUrl failed,err:%v\n", err)
	}
    //获取URL结构体
	data := url.Values{}		//type Values map[string][]string
    //声明一个请求参数map
	data.Set("name","jack")
	data.Set("age","7")
    data.Set("age","8")
    //8会把7顶掉。
    data.Add("age","7")
	//使用Add方法添加数组
	u.RawQuery = data.Encode()
    //将请求字段和URL进行拼接
	resp, err := http.Get(u.String())
	//调用URL对象的String方法返回url字符串
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}
	fmt.Println(string(b))
}
```

[解析效果]()

```json
{ age: [ '7', '71' ], name: 'jack' }
```



## 发送POST请求 📫

### http.Post🛸

http.Post有三个请求参数分别是url，content-Type 和 io.Reader接口实现者

```go
package main

func main() {
	url := "http://127.0.0.1:3000/postData?id=1"
	contentType := "application/json"
	data := `{"name":"小王子",age:18}`
	resp, err := http.Post(url,contentType,strings.NewReader(data))
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)
	fmt.Println(string(b))
}

```

#### resp.Body

请求返回的响应体，是一个实现了`Reader`接口的数据类型，可以直接使用`ReadAll`读取字节数组内容，读取完一定要关闭。

```go
defer resp.Body.Close()
```

#### 添加请求体📋

##### Post

这里我们只需要根据请求体`（io.Reader）`填写`Content-Type`就行了。

```go
func Post(url, contentType string, body io.Reader) (resp *Response, err error) {
	return DefaultClient.Post(url, contentType, body)
}
```

##### 表单数据

```go
func main() {
	url := "http://127.0.0.1:3000/postData?id=1"

	// 表单数据
	contentType := "application/x-www-form-urlencoded"
	data := "name=小王子&age=18"

	resp, err := http.Post(url,contentType,br)

	if err != nil {
		panic(err)
	}

	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)

	fmt.Println(string(b))
}

```

##### JSON数据

```go
func main() {
	url := "http://127.0.0.1:3000/postData?id=1"
	contentType := "application/json"
	data := `{"name":"小王子",age:18}`
	resp, err := http.Post(url,contentType,strings.Newreader(data))
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)
	fmt.Println(string(b))
}

```

##### 其他媒体类型（img/avi/MP4*文件）

```go
package main

func readFileWithBufio(path string) io.Reader {
	fr, err := os.Open(path)
	if err != nil {
		panic(err)
	}
	br := bufio.NewReader(fr)
	return br
}

func main() {
	url := "http://127.0.0.1:3000/postData?id=1"
	contentType := "image/jpeg"
	br := readFileWithBufio("121.jpg")
	resp, err := http.Post(url,contentType,br)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	b, err := ioutil.ReadAll(resp.Body)
	fmt.Println(string(b))
}

```

### 添加 query 参数🔌

> 同上

## Client发送有请求头的请求📤

http.Client和http.NewRequest来模拟请求

```go
package main

func main() {
    client := &http.Client{}//客户端,被Get,Head以及Post使用
    reqest, err := http.NewRequest("POST", "http://xxx.com/logindo", nil)
    if err != nil {
        fmt.Println("Fatal error ", err.Error())
    }
    reqest.Header.Set("Content-Type", "application/x-www-form-urlencoded;param=value") 
    //必须设定该参数,POST参数才能正常提交
    resp, err := client.Do(reqest)
    //发送请求
    defer resp.Body.Close()
    //一定要关闭resp.Body
    content, err := ioutil.ReadAll(resp.Body)
    if err != nil {
        fmt.Println("Fatal error ", err.Error())
    }
    fmt.Println(string(content))
}
```

### type [Client](https://go-zh.org/src/net/http/client.go?s=897:2420#L26)

```go
type Client struct {
    Transport RoundTripper
    CheckRedirect func(req *Request, via []*Request) error
    Jar CookieJar
    Timeout time.Duration
}
```

创建一个Http客户端，只能发送Get,Head以及Post请求。

#### func (*Client) [Do](https://go-zh.org/src/net/http/client.go?s=6009:6070#L163)

```go
func (c *Client) Do(req *Request) (resp *Response, err error)
```

使用客户端类型发送一个请求。

#### func (*Client) [Get](https://go-zh.org/src/net/http/client.go?s=9726:9786#L285)

```go
func (c *Client) Get(url string) (resp *Response, err error)
```

使用客户端发送GET请求

#### func (*Client) [Head](https://go-zh.org/src/net/http/client.go?s=15627:15688#L493)

```go
func (c *Client) Head(url string) (resp *Response, err error)
```

使用客户端发送Head请求

#### func (*Client) [Post](https://go-zh.org/src/net/http/client.go?s=13807:13901#L442)

```go
func (c *Client) Post(url string, bodyType string, body io.Reader) (resp *Response, err error)
```

使用客户端发送Post请求

#### func (*Client) [PostForm](https://go-zh.org/src/net/http/client.go?s=14735:14817#L467)

```go
func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error)
```

使用客户端发送Post表单请求

## 创建默认客户端

```go
// http server

func sayStudent(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Hello student！")
}

func sayTeacher(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Hello teacher！")
}

func main() {
	http.HandleFunc("/students", sayStudent)
    http.HandleFunc("/students", sayTeacher)
    //路由
	err := http.ListenAndServe(":9090", nil)
	if err != nil {
		fmt.Printf("http server failed, err:%v\n", err)
		return
	}
}
```

### 流程：

#### 首先调用Http.HandleFunc

[按顺序做了几件事：]()

- 调用了DefaultServerMux的HandleFunc
- 调用了DefaultServerMux的Handle
- 往DefaultServeMux的map[string]muxEntry中增加对应的handler和路由规则

#### 其次调用http.ListenAndServe(“:8001”, nil)

[按顺序做了几件事情：]()

- 实例化Server

- 调用Server的ListenAndServe()

- 调用net.Listen(“tcp”, addr)监听端口

- 启动一个for循环，在循环体中Accept请求

- 对每个请求实例化一个Conn，并且开启一个goroutine为这个请求进行服务go c.serve()

- 读取每个请求的内容w, err := c.readRequest()

- 判断header是否为空，如果没有设置handler（这个例子就没有设置handler），handler就设置为DefaultServeMux

- 调用handler的ServeHttp

- 在这个例子中，下面就进入到DefaultServerMux.ServeHttp

- 根据request选择handler，并且进入到这个handler的ServeHTTP

  - ```go
    mux.handler(r).ServeHTTP(w, r)
    ```

- 选择handler：
  - A 判断是否有路由能满足这个request（循环遍历ServerMux的muxEntry）
  - B 如果有路由满足，调用这个路由handler的ServeHttp
  - C 如果没有路由满足，调用NotFoundHandler的ServeHttp

## http.Request结构体

```go
fmt.Println("Method",r.Method)
fmt.Println("URL",r.URL)
fmt.Println("Proto",r.Proto)
fmt.Println("Header",r.Header)
fmt.Println("ContentLength",r.ContentLength)
fmt.Println("Host",r.Host)
fmt.Println("Form",r.Form)
fmt.Println("PostForm",r.PostForm)
fmt.Println("RequestURI",r.RequestURI)
fmt.Println("TransferEncoding",r.TransferEncoding)
/**
    Method POST
    请求方法（字符串）
    URL /postData?id=1	
    URL结构体
    Proto HTTP/1.1	
    协议名（字符串）
    Header map[Accept-Encoding:[gzip] Content-Type:[image/jpeg] User-Agent:[Go-http-client/1.1]] 
    请求头（map类型）{type Header map[string][]string}
    ContentLength -1
    请求体大小
    Host 127.0.0.1:3000
    端口号
    Form map[]
    PostForm map[]
    RequestURI /postData?id=1
    TransferEncoding [chunked]
```

## 解析GET请求📨

解析GET请求的`handler`（路由）

```go
func getHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	data := r.URL.Query()
	fmt.Println(data.Get("name"))
	fmt.Println(data.Get("age"))
	answer := `{"status": "ok"}`
	w.Write([]byte(answer))
}
```

## 解析POST请求📠

解析POST请求的`handler`（路由）

```go
func postHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	// 1. 请求类型是application/x-www-form-urlencoded时解析form数据
	r.ParseForm()
	fmt.Println(r.PostForm) // 打印form数据
	fmt.Println(r.PostForm.Get("name"), r.PostForm.Get("age"))
	// 2. 请求类型是application/json时从r.Body读取数据
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Println("read request.Body failed, err:%v\n", err)
		return
	}
	fmt.Println(string(b))
	answer := `{"status": "ok"}`
	w.Write([]byte(answer))
}
```

