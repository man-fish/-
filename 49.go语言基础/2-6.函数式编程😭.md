# 函数式编程😭

## 闭包😜

![1574921700218](F:\我的笔记\image\1574921700218.png)

> 实现原理，函数返回的时候不只返回了返回函数的代码段，还返回了对局部变量/常量的引用，所以局部变量不会被垃圾回收。

#### 非正规闭包😋

> 闭包有正统的方式也有非正统的方式，非正统的方式中我们使用自由变量缓存数据避免局部变量被垃圾回收，比如说下面的代码。

```go
package main
import "fmt"

func adder() func(int) int /** 返回值是一个参数和返回值都为int的函数 */ {
	var sum int = 0
	return func(v int) int {
		sum += v
		return sum
	}
}

func main(){
	a := adder()
	for i := 0; i < 10; i++ {
		fmt.Println(a(i))
	}
}
```



#### 正统闭包😁

> 正统的闭包有如下规则 ：
>
> ![1574920523237](F:\我的笔记\image\1574920523237.png)

可以看到这里我们的函数就只有一个参数，并且只使用常量来实现不可变性。

```go
package main

import "fmt"

type iAdder func(int) (int, iAdder)

func tealAdder(base int) iAdder {
	return func(v int) (int, iAdder){
		return base+v, tealAdder(base+v)
	}
}

func main(){
	b := tealAdder(0)	//常数

	for i := 1; i < 10; i++ {
		var k int
		k, b = b(i)
		fmt.Println(k)
	}
}
```



## 函数作为一等公民😡

#### 高阶函数（函数作为参数）

```go
package main

import (
	"fmt"
)

type TreeNode struct {
	//声明结构体
	Value       int
	Left, Right *TreeNode
}

func main() {
	var root TreeNode
	root = tree.TreeNode{Value: 3}
	root.Ftverse(func(node *tree.TreeNode){
		fmt.Println("回调函数",node.Value)
	})
}
```

```go
package tree

func (node *TreeNode) Ftverse(f func(node *TreeNode)){
	if(node == nil){
		return
	}
	node.Left.Ftverse(f)
	f(node)
	node.Right.Ftverse(f)
}
```

