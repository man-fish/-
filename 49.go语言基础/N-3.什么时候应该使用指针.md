# when ptr ？

**在go语言中想要知道自己应该什么时候使用指针，就需要先知道go语言的值类型和引用类型：**

在Go语言中，对于`布尔变量、数值类型、字符串类型、数组、结构体`都是按照值传递的：值在传递给函数或者方法时会被复制一份，然后方法或函数使用的是复制的这份值，也就不会对原值产生什么影响。一般情况下，对于布尔变量或数值类型或字符串类型的按值传递是非常廉价的，Go语言编译器会在传递过程中进行安全优化。

## 在结构体中什么时候应该使用指针?

就说结构体，对于一个结构体来说，我们可以直接访问其属性也可以通过结构者方法访问其属性，直接访问结构体属性时，不管是结构体的指针还是值我们都可以直接打点调用或者修改其属性，当然访问的就是其本身，修改会对其产生效果。

但是当结构体作为参数传入函数时，如果传入的不是指针就会发生一次拷贝，对其拷贝进行属性的修改可能产生一下两种情况：

#### 修改的属性是一个指针类型

```go
package main

import (
	"fmt"
)

type dog struct {
	name string
}

type stu struct {
	name string
	pet  *dog
}

func (s stu)setName() {
	s.pet.name = "snopy"
}

func main() {
	stu1 := stu{name:"Googly",pet:new(dog)}
	stu1.setName()
	fmt.Println(stu1.pet.name)
}
//snopy
```

#### 修改的属性是值类型

```go
package main

import (
	"fmt"
)

type dog struct {
	name string
}

type stu struct {
	name string
	pet  dog
}

func (s stu)setName() {
	s.pet.name = "snopy"
}

func main() {
	stu1 := stu{name:"Googly",pet:dog{}}
	stu1.setName()
	fmt.Println(stu1.pet.name)
}
//nil
```

###### [总结来说]()

向函数内传入结构体的时候是值类型传递，在函数内部修改其属性不会对实际传入的结构体产生影响，但是如果传入的结构体的某一个属性是一个指针，那么修改这个属性就会对结构体造成影响

#### 结论

联合数据结构去想，结构体的私有属性是值类型和指针类型其实都可以，其最终还是由我们定义的接收者方法来决定，不过都使用指针类型能够很好的确保其更改有效。

```go
type chick struct {
	name string
}

type dog struct {
	name string
	father chick
}

type stu struct {
	name string
	pet  dog
}

func (s *stu)setName() {
	s.pet.father.name = "kk"
}
func main() {
	stu1 := &stu{name:"wang",pet:dog{"papi",chick{}}}
	fmt.Println(stu1.pet.father.name)
}

//kk
```

不管要修改的结构体是第几层引用，只要传入当前函数的执行栈的结构体是指针类型，那么对其所以属性的更改都会生效。