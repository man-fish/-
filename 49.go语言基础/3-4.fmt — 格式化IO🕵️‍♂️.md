# fmt — 格式化IO🕵️‍♂️

> fmt 包实现了格式化I/O函数，类似于C的 printf 和 scanf. 格式“占位符”衍生自C，但比C更简单，fmt包不是用来实现控制台输出的重要的事情说100遍

##### 分类

> - fmt.P$( )		//将数据输出到控制台
> - fmt.Fp$( )	  //将数据输出到**io.Write**接口的实现者
> - fmt.Sp$( )	   //将数据输出到string()

##### 底层原理

`源码`

```go
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrint(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
```

可以看到我们讲格式化好的字节数组输入到io.Writer中，再由io.Writer的实现者来写入，平时我们比较常用的由stdOut也就是控制台的写入实现者。

`源码`

```go
func Sprint(a ...interface{}) string {
	p := newPrinter()
	p.doPrint(a)
	s := string(p.buf)
	p.free()
	return s
}
```

可以看到这里我们将参数传进去之后**p := newPrinter()，p.doPrint(a)**将参数转换位字节数组，最后由**string()**来转换成string类型返回。



## fmt.P$👨‍✈️

P开头的一般指控制台输出

> - fmt.Print( )	//将数据输出到控制台
> - fmt.Printf( )   //将数据格式化并且输出到控制台。
> - fmt.Println( ) //将数据输出到控制台并且换行。

##### 底层原理

`源码`

```go
func Print(a ...interface{}) (n int, err error) {
	return Fprint(os.Stdout, a...)
}
```

可以看到Print函数将数据通过Fprint转换成byte数组输入到io.Stdout中，Stdout的write方法负责讲字节数组标准写入到控制台中，这就是我们平时使用的控制台输出的基本实现原理。

### fmt.Printf格式化输出🧔

##### 占位符

```go
func main(){
	fmt.Printf("%%")
	fmt.Println()
	fmt.Println("单纯的输出百分号")

	fmt.Printf("%t",true)
	fmt.Println()
	fmt.Println("单纯的输出真假值（true/false）")

	fmt.Printf("%v","string")
	fmt.Println()
	fmt.Println("原格式输出")
	fmt.Printf("%T","string")
	fmt.Println()
	fmt.Println("打印数据类型")

	fmt.Printf("%d",12)
	fmt.Println()
	fmt.Println("十进制方法表示，只能传递int")
	fmt.Printf("%b",12)
	fmt.Println()
	fmt.Println("二进制方法表示，只能传递int")

	fmt.Printf("%q","string")
	fmt.Println()
	fmt.Println("双引号围绕的字符串，由Go语法安全地转义")

	fmt.Printf("%s", []byte("Go语言中文网"))
	fmt.Println()
	fmt.Println("输出字符串表示（string类型或[]byte)")

	fmt.Printf("%c", 0x4E2D)
	fmt.Println()
	fmt.Println("相应Unicode码点所表示的字符")
}
```

##### 格式化错误

如果给占位符提供了无效的实参（例如将一个字符串提供给 %d），所生成的字符串会包含该问题的描述，如下例所示：

```bash
    类型错误或占位符未知：%!verb(type=value)
        Printf("%d", hi):          %!d(string=hi)
    实参太多：%!(EXTRA type=value)
        Printf("hi", "guys"):      hi%!(EXTRA string=guys)
    实参太少： %!verb(MISSING)
        Printf("hi%d"):            hi %!d(MISSING)
    宽度或精度不是int类型: %!(BADWIDTH) 或 %!(BADPREC)
        Printf("%*s", 4.5, "hi"):  %!(BADWIDTH)hi
        Printf("%.*s", 4.5, "hi"): %!(BADPREC)hi
    所有错误都始于“%!”，有时紧跟着单个字符（占位符），并以小括号括住的描述结尾。
```



## fmt.Sp$👨‍🎨

Sp开头的一般指控制台输出

> - fmt.Sprint( )	//将数据转化为字符串。
> - fmt.Sprintf( )   //将数据格式化并且转化为字符串。
> - fmt.Sprintln( ) //将数据转化为字符串并且添加换行。

```go
package main

import "fmt"

type lion struct {
	age int
	name string
}

func (l lion) String() string {
	return fmt.Sprint("狮子名叫",l.name,"，今年",l.age,"岁了。")
}

func main(){
    xb := lion{name:"xinba",age:7}
	fmt.Print(xb)
	fmt.Printf("%T",fmt.Sprint("狮子名叫","，今年","岁了。"))
}
```

```go
狮子名叫xinba，今年7岁了。
string
```



## fmt.Fp$👩‍🏫

Sp开头的一般指控制台输出

> - fmt.Fprint( )	//将数据输出到wtiter接口的实现者。
> - fmt.Fprintf( )   //将数据格式化并且输出到wtiter接口的实现者。
> - fmt.Fprintln( ) //将数据输出到wtiter接口的实现者并且添加换行。

`源码`

```go
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

```go
func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
	p := newPrinter()
	p.doPrint(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}
```

可以看到我们讲格式化好的字节数组输入到io.Writer中，再由io.Writer的实现者来写入，平时我们比较常用的由stdOut也就是控制台的写入实现者。



## 获取输入🎊

Go语言`fmt`包下有`fmt.Scan`、`fmt.Scanf`、`fmt.Scanln`三个函数，可以在程序运行过程中从标准输入获取用户的输入。

### fmt.Scan

函数定签名如下：

```go
func Scan(a ...interface{}) (n int, err error)
```

- Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。
- 本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。

具体代码示例如下：

```go
func main() {
	var (
		name    string
		age     int
		married bool
	)
	fmt.Scan(&name, &age, &married)
	fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)
}
```

将上面的代码编译后在终端执行，在终端依次输入`小王子`、`28`和`false`使用空格分隔。

```bash
$ ./scan_demo 
小王子 28 false
扫描结果 name:小王子 age:28 married:false 
```

`fmt.Scan`从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。

### fmt.Scanf

函数签名如下：

```go
func Scanf(format string, a ...interface{}) (n int, err error)
```

- Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。
- 本函数返回成功扫描的数据个数和遇到的任何错误。

代码示例如下：

```go
func main() {
	var (
		name    string
		age     int
		married bool
	)
	fmt.Scanf("1:%s 2:%d 3:%t", &name, &age, &married)
	fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)
}
```

将上面的代码编译后在终端执行，在终端按照指定的格式依次输入`小王子`、`28`和`false`。

```bash
$ ./scan_demo 
1:小王子 2:28 3:false
扫描结果 name:小王子 age:28 married:false 
```

`fmt.Scanf`不同于`fmt.Scan`简单的以空格作为输入数据的分隔符，`fmt.Scanf`为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。

例如，我们还是按照上个示例中以空格分隔的方式输入，`fmt.Scanf`就不能正确扫描到输入的数据。

```bash
$ ./scan_demo 
小王子 28 false
扫描结果 name: age:0 married:false 
```

### fmt.Scanln

函数签名如下：

```go
func Scanln(a ...interface{}) (n int, err error)
```

- Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。
- 本函数返回成功扫描的数据个数和遇到的任何错误。

具体代码示例如下：

```go
func main() {
	var (
		name    string
		age     int
		married bool
	)
	fmt.Scanln(&name, &age, &married)
	fmt.Printf("扫描结果 name:%s age:%d married:%t \n", name, age, married)
}
```

将上面的代码编译后在终端执行，在终端依次输入`小王子`、`28`和`false`使用空格分隔。

```bash
$ ./scan_demo 
小王子 28 false
扫描结果 name:小王子 age:28 married:false 
```

`fmt.Scanln`遇到回车就结束扫描了，这个比较常用。

### bufio.NewReader

有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用`bufio`包来实现。示例代码如下：

```go
func bufioDemo() {
	reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象
	fmt.Print("请输入内容：")
	text, _ := reader.ReadString('\n') // 读到换行
	text = strings.TrimSpace(text)
	fmt.Printf("%#v\n", text)
}
```

### Fscan系列

这几个函数功能分别类似于`fmt.Scan`、`fmt.Scanf`、`fmt.Scanln`三个函数，只不过它们不是从标准输入中读取数据而是从`io.Reader`中读取数据。

```go
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
```

### Sscan系列

这几个函数功能分别类似于`fmt.Scan`、`fmt.Scanf`、`fmt.Scanln`三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。

```go
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
```



## Stringer 接口🍝

Stringer接口的定义如下：

```go
    type Stringer interface {
        String() string
    }
```

根据 Go 语言中实现接口的定义，一个类型只要有 `String() string` 方法，我们就说它实现了 Stringer 接口。而在本节开始已经说到，如果格式化输出某种类型的值，只要它实现了 String() 方法，那么会调用 String() 方法进行处理。

```go
type lion struct {
	age int
	name string
}

func (l lion) String() string {
	return fmt.Sprint("狮子名叫",l.name,"，今年",l.age,"岁了。")
}

func main(){
    xb := lion{name:"狮子王",age:2}
	fmt.Print(xb)
	fmt.Printf("%T",fmt.Sprint("狮子名叫","，今年","岁了。"))
}
```

```go
狮子名叫xinba，今年7岁了。
string
```

