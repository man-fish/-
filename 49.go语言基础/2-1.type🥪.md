# type🥪

> type有如下几种用法：
>
> > - 类型定义
> >   - 定义结构体
> >   - 定义接口
> > - 类型别名
> > - 类型查询



### 类型定义🥩

使用类型定义定义出来的类型与原类型不相同，所以不能使用新类型变量赋值给原类型变量，除非使用强制类型转换。下面来看一段示例代码，根据string类型，定义一种新的类型，新类型名称是name：

```go
type name string
```

##### 为什么要使用类型定义呢？

类型定义可以在原类型的基础上创造出新的类型，有些场合下可以使代码更加简洁，如下边示例代码：

```go
package main

import (
	"fmt"
)

// 定义一个接收一个字符串类型参数的函数类型
type handle func(str string)

// exec函数，接收handle类型的参数
func exec(f handle) {
	f("hello")
}

func main() {
	// 定义一个函数类型变量，这个函数接收一个字符串类型的参数
	var p = func(str string) {
		fmt.Println("first", str)
	}
	exec(p)

    // 匿名函数作为参数直接传递给exec函数
    exec(func(str string) {
        fmt.Println("second", str)
    })
}
```

#### 定义结构体🍩

> 其实定义结构体和接口都属于定义类型的范畴，因为结构体和接口一般都需要一个额外的类型名作为函数参数等等。

结构体是用户自定义的一种抽象的数据结构，golang中struct类似于java语言中的class， 在程序设计中，有着举足轻重的地位。结构体的用法，将会在struct关键字中详细的介绍。下边来看一下定义一个结构体的语法格式：

```go
type name struct {
    Field1  dataType
    Field2  dataType
    Field3  dataType
}
```

#### 定义接口🍠

接口相关知识点，将会在interface关键字中详细介绍，下边来看一段定义接口的语法格式：

```go
type name interface{
    Read()
    Write()
}
```



### 类型别名💌

先来看一个最直观的例子，rune是go语言的字符类型，那么他的本质是是什么呢？

```go
func main() {
	var a rune = '爱'
	fmt.Printf("%T",a)
}
//int32
```

来看看bultin的源码（阉割版）

```go
package builtin

type string string

type int int

type byte = uint8

type rune = int32

type error interface {
	Error() string
}
```



### 类型查询😱

#### 类型别名💌

先来看一个最直观的例子，rune是go语言的字符类型，那么他的本质是是什么呢？

```go
func main() {
	var a rune = '爱'
	fmt.Printf("%T",a)
}
//int32
```

来看看bultin的源码（阉割版）

```go
package builtin

type string string

type int int

type byte = uint8

type rune = int32

type error interface {
	Error() string
}
```



#### 类型查询😱

> 类型查询，就是根据变量，查询这个变量的类型。为什么会有这样的需求呢？

goalng中有一个特殊的类型interface{}，这个类型可以被任何类型的变量赋值，如果想要知道到底是哪个类型的变量赋值给了interface{}类型变量，就需要使用类型查询来解决这个需求，示例代码如下：

```go
package main

import (
	"fmt"
)

func main() {
    // 定义一个interface{}类型变量，并使用string类型值”abc“初始化
    var a interface{} = "abc"
    
    // 在switch中使用 变量名.(type) 查询变量是由哪个类型数据赋值。
    switch v := a.(type) {
    case string:
    	fmt.Println("字符串")
    case int:
        fmt.Println("整型")
    default:
    	fmt.Println("其他类型", v)
    }
}
```

如果使用.(type)查询类型的变量不是interface{}类型，则在编译时会报如下错误：

```go
cannot type switch on non-interface value a (type string)
```

如果在switch以外地方使用.(type)，则在编译时会提示如下错误：

```go
use of .(type) outside type switch
```

所以，使用type进行类型查询时，只能在switch中使用，且使用类型查询的变量类型必须是interface{}

