# 接口🍗

> go语言接口和其他语言的不同，go语言接口有三个组成部分，struct接口体组成的实现者，接口，使用者，go语言最大的特点就是可以它通过接口实现鸭子类型来实现多态，（下面写错了），初学者如何理解接口，接口和struct甚至是int，string一样就是一个类型，而这个类型不约束数据只约束了方法。
>
> **——为了保护你的Go语言职业生涯，请牢记接口（interface）是一种类型。**

![未命名文件](F:\我的笔记\image\未命名文件.jpg)



## 为什么要使用接口🍻

```go
type Cat struct{}

func (c Cat) Say() string { return "喵喵喵" }

type Dog struct{}

func (d Dog) Say() string { return "汪汪汪" }

func main() {
	c := Cat{}
	fmt.Println("猫:", c.Say())
	d := Dog{}
	fmt.Println("狗:", d.Say())
}
```

上面的代码中定义了猫和狗，然后它们都会叫，你会发现main函数中明显有重复的代码，如果我们后续再加上猪、青蛙等动物的话，我们的代码还会一直重复下去。那我们能不能把它们当成“能叫的动物”来处理呢？

**像类似的例子在我们编程过程中会经常遇到：**

> - 比如一个网上商城可能使用支付宝、微信、银联等方式去在线支付，我们能不能把它们当成“支付方式”来处理呢？
> - 比如三角形，四边形，圆形都能计算周长和面积，我们能不能把它们当成“图形”来处理呢？
> - 比如销售、行政、程序员都能计算月薪，我们能不能把他们当成“员工”来处理呢？

Go语言中为了解决类似上面的问题，就设计了接口这个概念。接口区别于我们之前所有的具体类型，接口是一种抽象的类型。当你看到一个接口类型的值时，你不知道它是什么，唯一知道的是通过它的方法能做什么。



## 接口由使用者定义🍖

> **鸭子类型**（英语：**duck typing**）在[程序设计](https://zh.wikipedia.org/wiki/程序设计)中是[动态类型](https://zh.wikipedia.org/wiki/類型系統)的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由"当前[方法](https://zh.wikipedia.org/wiki/方法_(電腦科學))和属性的集合"决定。
>
> 在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为"鸭子"的对象，并调用它的"走"和"叫"方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的"走"和"叫"方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。比如使用者是一个吃货，那么在他眼中鸭子就有拿来烤的功能，而使用者是一个农场主，那鸭子就是一个鸭子。

![1574858106526](F:\我的笔记\image\1574858106526.png)

鸭子类型在java中是无法实现的，因为java定义的函数传入的参数必须是实现接口的类，而go传入的可以是接口的类型，也就是我们所说的不关乎他的实现者，关乎的只是那个接口，所以我们用多个实现者实现这个接口时，就可以形成一个多态。

![1574858936422](F:\我的笔记\image\1574858936422.png)

pthyon中也有鸭子类型，但是他的鸭子类型没有语法检查，就比如实现者没有实现接口定义的方法，那也没有提示，所以传进去的时候就会报错。

![1574859030884](F:\我的笔记\image\1574859030884.png)

在go中我们可以实现鸭子类型，多亏了他的接口的语法检查和接口的多态。

```go
package main

import (
	"fmt"
	"time"
	"go_learning/src/retriever/mock"
)

const url string = "http://www.imooc.com"

type Getter interface {
	Get(url string) string
}

func download(r Getter) string { /**使用者 */
	return r.Get(url)
}

func main() {
	var r Getter
	r = mock.Http{ Contents : "this is a facebook" }
}
```



## 声明一个接口🥩

> 在这里我们可以看到我们声明了Getter接口，在mock文件夹里用结构体实现了Getter接口的Get方法，不过整个过程我们并没有实际的指出mock中的Http实现了Getter，这个过程是隐式的，最后我们拖过定义函数来为接口添加功能。

###### interface

```go
package main

import (
	"fmt"
	"time"
	"go_learning/src/retriever/mock"
)

const url string = "http://www.imooc.com"

type Getter interface {
	Get(url string) string
}

func download(r Getter) string {
	return r.Get(url)
}

func main() {
	var r Getter
	r = mock.Http{ Contents : "this is a facebook" }
}
```

###### struct

```go
package mock

type Http struct {
	Contents string
}

func (r Http) Get(url string) string {
	return r.Contents
}
```



## 指针实现者🍠

> 我们可以看到这样我们实现的Get方法只能使用值传递，不利于我们对构造体（实现者）内部属性进行修改，所以我们最好将实现者实现的方法定义成指针接受者方法，不过要记住，如果一个你实现的函数都是指针接收者函数，那么你声明的实现者也一定要是指针类型。

###### interface

```go
package main

import (
	"fmt"
	"time"
	"go_learning/src/retriever/mock"
	"go_learning/src/retriever/real"
)

const url string = "http://www.imooc.com"

type Getter interface {
	Get(url string) string
}

func download(r Getter) string {
	return r.Get(url)
}

func main() {
	var r Getter
	r = &real.Http{
		//指针接收者方法只能传递指针
		UserAgent: "Mozilla/5.0",
		TimeOut: time.Minute,
	}
}
```

######  struct

```go
package real

import (
	"net/http"
	"net/http/httputil"
	"time"
)

type Http struct {
	UserAgent string
	TimeOut    time.Duration
}

func (r *Http) Get(url string) string {
	resp, err := http.Get(url)
	if err != nil {
		panic(err)
	}

	result, err := httputil.DumpResponse(resp, true)

	resp.Body.Close()

	if err != nil {
		panic(err)
	}

	return string(result)
}
```



## 一个接口实现者里到底有什么🍤

> 一个接口实现者里面包含他的实现者名称类型还有他包含的值，指针实现者就是指针，值实现者包含的就是值。

![7857657656](F:\我的笔记\image\7857657656.png)

```go
package main
import (
	"fmt"
	"time"
	"go_learning/src/retriever/mock"
	"go_learning/src/retriever/real"
)

type Getter interface {
	Get(url string) string
}

func main() {
	var r Getter
	r = &mock.Http{ Contents : "this is a facebook" }
	fmt.Printf("类型：%T 值：%v\n",r,r)
	r = &real.Http{
		//指针接收者方法只能传递指针
		UserAgent: "Mozilla/5.0",
		TimeOut: time.Minute,
	}
	fmt.Printf("类型：%T 值：%v\n",r,r)
}
//类型：*mock.Http 值：&{this is a facebook}
```



## 获取接口实现者的值🥡

![接口值图解](F:\我的笔记\image\interface.png)

##### Type Asserion

```go
package main

import (
	"fmt"
	"time"
	"go_learning/src/retriever/mock"
	"go_learning/src/retriever/real"
)

const url string = "http://www.imooc.com"

type Getter interface {
	Get(url string) string
}

func download(r Getter) string {
	return r.Get(url)
}

func main() {
	var r Getter
	r = &real.Http{
		//指针接收者方法只能传递指针
		UserAgent: "Mozilla/5.0",
		TimeOut: time.Minute,
	}

	//Type Asserion -> what means a Type Asserion?
	realHttp := r.(*real.Http)
    //首先我们要获取接受里面的实现者。
	fmt.Println(realHttp.TimeOut)
	//没加判断
	if mockHttp,ok := r.(*mock.Http);ok {
		fmt.Println(mockHttp.Contents)
	}
    //加判断，这里因为r的实现者已经变成了real,struct所以打点调用就会报错。
}
```



##### Type Switch

> 这样使用接收者更加灵活，避免出现问题。

```go
func inspect(r Getter) {
	fmt.Printf("类型：%T 值：%v\n",r,r)
	switch v := r.(type) {
	case *mock.Http:
		fmt.Println("Contents:",v.Contents)
	case *real.Http:
		fmt.Println("Contents:",v.UserAgent)
	}
}
```



## 接口组合🍱

> 接口组合，提高接口的可拓展性。

###### interface

```go
package main

import (
	"fmt"
	"time"
	"go_learning/src/retriever/mock"
	"go_learning/src/retriever/real"
)

const url string = "http://www.imooc.com"

type Getter interface {
	Get(url string) string
}

func download(r Getter) string {
	return r.Get(url)
}

type Poster interface {
	Post(url string,form map[string]string) string
}

func Post(poster Poster) {
	poster.Post(url,
		map[string]string {
			"name": "ccmouse",
			"course": "golang",
		})
}

type GetPoster interface {
	Getter
	Poster
}

func session(s GetPoster){
	s.Get(url)
	s.Post(url,map[string]string{
		"contents": "another faked imooc.com",
	})
}


func main() {
	var r Getter
	r = &mock.Http{ Contents : "this is a facebook" }
	fmt.Printf("类型：%T 值：%v\n",r,r)
	r = &real.Http{
		//指针接收者方法只能传递指针
		UserAgent: "Mozilla/5.0",
		TimeOut: time.Minute,
	}
	fmt.Printf("类型：%T 值：%v\n",r,r)
}
```

###### struct

```go
package mock

type Http struct {
	Contents string
}

func (r *Http) Get(url string) string {
	return r.Contents
}

func (r *Http) Post(url string, form map[string]string) string {
	r.Contents = form["contents"]
	return "ok"
}
```



## 接口使用注意点🥧

> - 不要使用接口的指针。
> - 实现者的接收者函数为指针接收者时，那么实现者的类型也要是也需要是指针。
>
> ```go
> func main() {
> 	var r Getter
> 	r = &mock.Http{ Contents : "this is a facebook" }
> 	fmt.Printf("类型：%T 值：%v\n",r,r)
> 	r = &real.Http{
> 		//指针接收者方法只能传递指针
> 		UserAgent: "Mozilla/5.0",
> 		TimeOut: time.Minute,
> 	}
> 	fmt.Printf("类型：%T 值：%v\n",r,r)
> }
> ```



## 接口做数据类型🥡

> 定义的接口可以作为一种数据类型，任何接口的实现者都可以视作符合这个数据类型，而当变量满足接口的数据类型的时候，就可以调用接口定义的函数。

```go
func ReadFrom(reader io.Reader, num int) ([]byte, error) {
	p := make([]byte, num)
	n, err := reader.Read(p)
	if n > 0 {
		return p[:n], nil
	}
	return p, err
}
```

这是官网的一个实例，这里的io.Reader就是官网定义的统一输入输出流接口，任何实现了Reader接口的实现者都可以传进去。

```go
// 从标准输入读取
data, err = ReadFrom(os.Stdin, 11)

// 从普通文件读取，其中 file 是 os.File 的实例
data, err = ReadFrom(file, 9)

// 从字符串读取
data, err = ReadFrom(strings.NewReader("from string"), 12)
```



## 空接口🍫

`interface{}`代表空接口,这个接口没有实现任何方法，所以可以代表任何类型。

假设有一个队列

```go
type Queue []int
```

如果定义为int的话当然只能往里面加int，但是如果您定义成空接口，就可以传任何值。

```go
type Queue [] interface{}
```

但是在往里面你传值的时候，你可以通过方法限定值得类型

```go
func (q *Queue) Push(v int) {
	*q = append(*q, v)
}
```



## Go语言接口的好处🥙

这样好处是显而易见的，我们拥有非常高的灵活性，同时保证在编译前就能检测到错误。尤其是在团队开发的时候，**在其他编程语言当中，都是谁提供服务，谁提供接口。你需要调用我的服务，就必须声明你实现了我的接口。**

而这在逻辑上实际是说不通的，服务实现者怎么会确切的知道服务使用者的具体需求呢？当需求发生变化的时候，服务实现者就需要考虑使用者的需求，从而设计接口。而从理论上来说，每一个服务的开发人员都应该专注于自己的服务。

而go语言不同。go语言的接口是非侵入式接口，只要调用者本身实现了该接口的全部方法，就默认实现了该接口（事实上也确实是实现了这个接口），而不需要显示的声明实现某个接口。这极大的方便了接口的调用，开发人员不必再需要苦想接口的粒度，只需要专注功能函数的实现就可以了。