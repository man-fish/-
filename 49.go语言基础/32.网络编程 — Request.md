# Request 🏫

`http.Request`一个通用的http请求流接口，他出现在`func HandleFunc (w http.ResponseWriter,r *http.Request)`和`func NewRequest(method, url string, body io.Reader) (*Request, error)`的返回值中，作为一个负责请求流书写和解析的对象。

## 结构体

```go
type Request struct {
	Method string
    Proto string
    Host string
    RequestURI string
    Header Header
	URL *url.URL
	Body io.ReadCloser
	ContentLength int64
	PostForm url.Values
	MultipartForm *multipart.Form
}
```



### Method、Proto、Host、RequestURI

这些字段在`HandleFunc`中用作解析请求流，在 `NewRequest`负责构建请求流（根据你传入的URL自动构建）。

```go
Method 		POST		//请求方式
URL 		/id?i=1		//路径+参数
Proto 		HTTP/1.1	//协议版本号
Host 		127.0.0.1:3000	//请求主机名
RequestURI 	/id?i=1		//路径+参数
```



### Header

`Header`字段是一个map类型，在`HandleFunc`中用作解析请求头，在 `NewRequest`负责构建请求头。

```go
type Header map[string][]string

func (h Header) Add(key, value string) {
	textproto.MIMEHeader(h).Add(key, value)
}

func (h Header) Set(key, value string) {
	textproto.MIMEHeader(h).Set(key, value)
}

func (h Header) Get(key string) string {
	return textproto.MIMEHeader(h).Get(key)
}

func (h Header) Del(key string) {
	textproto.MIMEHeader(h).Del(key)
}
```

###### NewRequest示例

```go
req, _ := http.NewRequest("POST", "http://example.com", strings.NewReader(data))
req.Header.Add("If-None-Match", `W/"wyzzy"`)
```



### URL

`URL`字段其实是一个`url.URL`结构体，在`HandleFunc`中用作解析请求头，在 `NewRequest`负责构建请求参数（后文会说）。

#### URL结构体格式

```go
type URL struct {
	Scheme     string    // no use
	Opaque     string    // no use
	User       *Userinfo // no use
    RawPath    string    // no use
    Fragment   string    // fragment for references, without '#'	no use
    ForceQuery bool      // append a query ('?') even if RawQuery is empty   no use
	Host       string    // host or host:port
	Path       string    // pathname without query
	RawQuery   string    // encoded query values, without '? like 'id=1&love=1
}
```

###### String方法

```go
func (u *URL) String() string
```

###### Query方法

返回的是一个url.Values可以调用get和set方法

```go
func (u *URL) Query() Values {   v, _ := ParseQuery(u.RawQuery)   return v}
```

#### url.Values 类型

> 其实是一个类型别名
>
> - type Values map[string][]string

###### Set方法

```go
func (v Values) Set(key, value string) {
	v[key] = []string{value}
}
```

###### Add方法

```go
func (v Values) Add(key, value string) {
	v[key] = append(v[key], value)
}
```

###### Encode方法

```go
func (v Values) Encode() string
```

#### HandleFunc解析Get请求实例

```go
func getHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	data := r.URL.Query()
	fmt.Println(data.Get("name"))
	fmt.Println(data.Get("age"))
	answer := `{"status": "ok"}`
	w.Write([]byte(answer))
}
```



### Body、ContentLength

不管是创建还是解析请求流的时候`Body`都是真正存储数据的地方（除了GET请求），它是一个`IO.ReadCloser`对象提供了`Read`接口，我们可以直接读取其内容（字节数组）。

```go
func postHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	// 1. 请求类型是application/x-www-form-urlencoded时解析form数据
	r.ParseForm()
	fmt.Println(r.PostForm) // 打印form数据
	fmt.Println(r.PostForm.Get("name"), r.PostForm.Get("age"))
	// 2. 请求类型是application/json时从r.Body读取数据
	b, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Println("read request.Body failed, err:%v\n", err)
		return
	}
	fmt.Println(string(b))
	answer := `{"status": "ok"}`
	w.Write([]byte(answer))
}
```



### PostForm

当我们的请求类型是`application/x-www-form-urlencoded`时解析我们通常需要解析这样的`Form`数据`id=1&name=2`，`go`为我们提供了内置函数来解决这个问题，PostForm内部也是url.Values类型

```go
type Values map[string][]string
```

###### 解析表单请求

```go
func postHandler(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()
	r.ParseForm()
    // 请求类型是application/x-www-form-urlencoded时解析form数据
	fmt.Println(r.PostForm) 
    // 打印form数据
	fmt.Println(r.PostForm.Get("name"), r.PostForm.Get("age"))
    // 获取form数据
}
```



### MultipartForm

这个不予赘述，当我们文件上传时用来解析文件，使用原理和`PostForm`差不多

```go
type Form struct {
	Value map[string][]string
	File  map[string][]*FileHeader
}
```

## 接收者方法

### io.Writer的Write方法

```
func (r *Request) Write(w io.Writer) error {
	return r.write(w, false, nil, nil)
}
```

### Cookie相关方法

```go
func (r Request) Cookies() []Cookie {
	return readCookies(r.Header, "")
}

var ErrNoCookie = errors.New("http: named cookie not present")

func (r Request) Cookie(name string) (Cookie, error) {
	for _, c := range readCookies(r.Header, name) {
		return c, nil
	}
	return nil, ErrNoCookie
}

func (r *Request) AddCookie(c *Cookie) {
	s := fmt.Sprintf("%s=%s", sanitizeCookieName(c.Name), sanitizeCookieValue(c.Value))
	if c := r.Header.Get("Cookie"); c != "" {
		r.Header.Set("Cookie", c+"; "+s)
	} else {
		r.Header.Set("Cookie", s)
	}
}
```

### BasicAuth相关方法

```go
func (r *Request) BasicAuth() (username, password string, ok bool) {
	auth := r.Header.Get("Authorization")
	if auth == "" {
		return
	}
	return parseBasicAuth(auth)
}

func parseBasicAuth(auth string) (username, password string, ok bool) {
	const prefix = "Basic "
	// Case insensitive prefix match. See Issue 22736.
	if len(auth) < len(prefix) || !strings.EqualFold(auth[:len(prefix)], prefix) {
		return
	}
	c, err := base64.StdEncoding.DecodeString(auth[len(prefix):])
	if err != nil {
		return
	}
	cs := string(c)
	s := strings.IndexByte(cs, ':')
	if s < 0 {
		return
	}
	return cs[:s], cs[s+1:], true
}

// parseBasicAuth parses an HTTP Basic Authentication string.
// "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==" returns ("Aladdin", "open sesame", true).
```

