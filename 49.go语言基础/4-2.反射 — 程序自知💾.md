# 反射 — 程序自知💾

## 变量的内在机制😼

Go语言中的变量是分为两部分的:

- 类型信息：预先定义好的元信息。
- 值信息：程序运行过程中可动态变化的。

## 反射介绍🚿

反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。

支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。Go程序在运行期使用reflect包访问程序的反射信息。  并且reflect包提供了reflect.TypeOf和reflect.ValueOf两个函数来获取任意对象的Value和Type。

## reflect包🍟

在Go语言的反射机制中，任何接口值都由是`一个具体类型`和`具体类型的值`两部分组成的(我们在上一篇接口的博客中有介绍相关概念)。 在Go语言中反射的相关功能由内置的reflect包提供，任意接口值在反射中都可以理解为由`reflect.Type`和`reflect.Value`两部分组成，并且reflect包提供了`reflect.TypeOf`和`reflect.ValueOf`两个函数来获取任意对象的Value和Type。

## TypeOf👙

在Go语言中，使用`reflect.TypeOf()`函数可以获得任意值的类型对象`（reflect.Type）`，程序通过类型对象可以访问任意值的类型信息，这里`Typeof`返回的是元类型信息。

```go
package main

import (
	"fmt"
	"reflect"
)

func main() {
	var a rune
	fmt.Println(reflect.TypeOf(a))		//int32
}
```

### Name( )和kind( )

在反射中关于类型还划分为两种：`类型（Type）`和`种类（Kind）`。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而`种类（Kind）`就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到`种类（Kind）`。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。

```go
package main

import (
	"fmt"
	"reflect"
)

func reflectType(x interface{}){
	t := reflect.TypeOf(x)
	fmt.Printf("type %v, prototype %v \n",t.Name(),t.Kind())
}

type myInt int64

type person struct {
	name string
}

func main() {
	var a rune			//类型别名
	var b myInt			//自定义类型
	var c *float32		//指针
	var d person		//其实也算是类型别名，但是结构体
	var e chan int		//管道
	var f []int			//切片
	var g [5]int		//数组

	reflectType(a)		//type int32	, prototype int32
	reflectType(b)		//type myInt	, prototype int64
	reflectType(c)		//type 			, prototype ptr
	reflectType(d)		//type person	, prototype struct
	reflectType(e)		//type 			, prototype chan
	reflectType(f)		//type 			, prototype slice
	reflectType(g)		//type			, prototype array
}
```

Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的`.Name()`都是返回`空`。

在`reflect`包中定义的Kind类型如下：

```go
type Kind uint
const (
    Invalid Kind = iota  // 非法类型
    Bool                 // 布尔型
    Int                  // 有符号整型
    Int8                 // 有符号8位整型
    Int16                // 有符号16位整型
    Int32                // 有符号32位整型
    Int64                // 有符号64位整型
    Uint                 // 无符号整型
    Uint8                // 无符号8位整型
    Uint16               // 无符号16位整型
    Uint32               // 无符号32位整型
    Uint64               // 无符号64位整型
    Uintptr              // 指针
    Float32              // 单精度浮点数
    Float64              // 双精度浮点数
    Complex64            // 64位复数类型
    Complex128           // 128位复数类型
    Array                // 数组
    Chan                 // 通道
    Func                 // 函数
    Interface            // 接口
    Map                  // 映射
    Ptr                  // 指针
    Slice                // 切片
    String               // 字符串
    Struct               // 结构体
    UnsafePointer        // 底层指针
)
```

## ValueOf🍨

`reflect.ValueOf()`返回的是`reflect.Value`类型，其中包含了原始值的值信息。`reflect.Value`与原始值之间可以互相转换，当然并没有什么卵用。

`reflect.Value`类型提供的获取原始值的方法如下：

|           方法            |                             说明                             |
| :-----------------------: | :----------------------------------------------------------: |
| **Interface() interface** | 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型  |
|      **Int() int64**      |     将值以 int 类型返回，所有有符号整型均可以此方式返回      |
|     **Uint() uint64**     |     将值以 uint 类型返回，所有无符号整型均可以此方式返回     |
|    **Float() float64**    | 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 |
|      **Bool() bool**      |                     将值以 bool 类型返回                     |
|    **Bytes() []bytes**    |               将值以字节数组 []bytes 类型返回                |
|    **String() string**    |                     将值以字符串类型返回                     |

### 通过反射获取值

```go
func reflectValue(x interface{}) {
	v := reflect.ValueOf(x)
	k := v.Kind()
	switch k {
	case reflect.Int64:
		// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换
		fmt.Printf("type is int64, value is %d\n", int64(v.Int()))
	case reflect.Float32:
		// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换
		fmt.Printf("type is float32, value is %f\n", float32(v.Float()))
	case reflect.Float64:
		// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换
		fmt.Printf("type is float64, value is %f\n", float64(v.Float()))
	}
}
func main() {
	var a float32 = 3.14
	var b int64 = 100
	reflectValue(a) // type is float32, value is 3.140000
	reflectValue(b) // type is int64, value is 100
	// 将int类型的原始值转换为reflect.Value类型
	c := reflect.ValueOf(10)
	fmt.Printf("type c :%T\n", c) // type c :reflect.Value
}
```

### 通过反射设置变量的值

`reflect.Value`类型提供的修改原始值的方法如下：

|          方法          |                             说明                             |
| :--------------------: | :----------------------------------------------------------: |
|   **SetInt() int64**   |        更改值为 int 类型，所有有符号整型均可以此方式         |
|   **Uint() uint64**    |        更改值为 uint 类型，所有无符号整型均可以此方式        |
| **SetFloat() float64** | 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 |
|   **SetBool() bool**   |                       更改值为布尔类型                       |
| **SetBytes() []bytes** |                        更改值为字节型                        |
| **SetString() string** |                        更改值为字符串                        |

想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的`Elem()`方法来获取指针对应的值。

```go
package main

import (
	"fmt"
	"reflect"
)

func reflectSetValue1(x interface{}) {
	v := reflect.ValueOf(x)
	if v.Kind() == reflect.Int64 {
		v.SetInt(200) //修改的是副本，reflect包会引发panic
	}
}
func reflectSetValue2(x interface{}) {
	v := reflect.ValueOf(x)
	// 反射中使用 Elem()方法获取指针对应的值
	if v.Elem().Kind() == reflect.Int64 {
		v.Elem().SetInt(200)
	}
}
func main() {
	var a int64 = 100
	// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value
	reflectSetValue2(&a)
    var p = new(float32)
	reflectSetValue(p)
	fmt.Println(a)
}
```

### isNil()和isValid()

#### isNil()

```go
func (v Value) IsNil() bool
```

`IsNil()`报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。

#### isValid()

```go
func (v Value) IsValid() bool
```

`IsValid()`返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。

#### 举个例子

`IsNil()`常被用于判断指针是否为空；`IsValid()`常被用于判定返回值是否有效。

```go
func main() {
	// *int类型空指针
	var a *int
	fmt.Println("var a *int IsNil:", reflect.ValueOf(a).IsNil())
	// nil值
	fmt.Println("nil IsValid:", reflect.ValueOf(nil).IsValid())
	// 实例化一个匿名结构体
	b := struct{}{}
	// 尝试从结构体中查找"abc"字段
	fmt.Println("不存在的结构体成员:", reflect.ValueOf(b).FieldByName("abc").IsValid())
	// 尝试从结构体中查找"abc"方法
	fmt.Println("不存在的结构体方法:", reflect.ValueOf(b).MethodByName("abc").IsValid())
	// map
	c := map[string]int{}
	// 尝试从map中查找一个不存在的键
	fmt.Println("map中不存在的键：", reflect.ValueOf(c).MapIndex(reflect.ValueOf("娜扎")).IsValid())
}
```

### 通过Type( )（Value结构体）拿到对应的Type结构体

可以这么拿但是不能反着拿。

```go
func (v Value) Type() Type {}
```

## 结构体反射🔬

任意值通过`reflect.TypeOf()`获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（`reflect.Type`）的`NumField()`和`Field()`方法获得结构体成员的详细信息。

`reflect.Type`中与获取结构体成员相关的的方法如下表所示。

|                            方法                             |                             说明                             |
| :---------------------------------------------------------: | :----------------------------------------------------------: |
|                  Field(i int) StructField                   |          根据索引，返回索引对应的结构体字段的信息。          |
|                       NumField() int                        |                   返回结构体成员字段数量。                   |
|        FieldByName(name string) (StructField, bool)         |       根据给定字符串返回字符串对应的结构体字段的信息。       |
|            FieldByIndex(index []int) StructField            | 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。 |
| FieldByNameFunc(match func(string) bool) (StructField,bool) |              根据传入的匹配函数匹配需要的字段。              |
|                       NumMethod() int                       |                返回该类型的方法集中方法的数目                |
|                     Method(int) Method                      |                返回该类型方法集中的第i个方法                 |
|             MethodByName(string)(Method, bool)              |              根据方法名返回该类型方法集中的方法              |

### Field() 方法

Type或者是Value结构体都可以使用方法。

```go
func (v Value) Field(i int) Value {}
```

```go
func (t Type) Field(i int) StructField {}
```

### StructField类型

`StructField`类型用来描述结构体中的一个字段的信息。

`StructField`的定义如下：

```go
type StructField struct { 
    Name    string		// Name是字段的名字
    PkgPath string		// PkgPath是非导出字段的包路径，对导出字段该字段为""
    Type      Type      // 字段的类型
    Tag       StructTag // 字段的标签
    Offset    uintptr   // 字段在结构体中的字节偏移量
    Index     []int     // 用于Type.FieldByIndex时的索引切片
    Anonymous bool      // 是否匿名字段
}
```

### 遍历NumField()

我们可以通过t/v任意一个返回的NumField来获取字段的id，然后就能通过v/t获取所有的信息。

#### 先t后v

不推荐，还需要额外的通过ValueOf拿到Value

```go
func mapStruct(x interface{}){
	t := reflect.TypeOf(x)
	v := reflect.ValueOf(x)
	if t.Kind() != reflect.Ptr || t.Elem().Kind() != reflect.Struct {
		panic("we need a ptr of struct !!")
	}
	for i := 0; i < t.Elem().NumField(); i++ {
		fmt.Printf("value? = %v \n",v.Elem().Field(i).Interface())
        //遍历值
		fmt.Printf("struct name:%v,struct tag:%v,struct type:%v,struct index:%v \n",t.Elem().Field(i).Name,t.Elem().Field(i).Tag,t.Elem().Field(i).Type,t.Elem().Field(i).Index)
        //遍历字段
	}
}
```

#### 先v后t

```go
func mapStruct(x interface{}) (err error) {
	t := reflect.TypeOf(x)
	v := reflect.ValueOf(x)
	if t.Kind() != reflect.Ptr || t.Elem().Kind() != reflect.Struct {
		//确认传入的是结构体指针类型
		err = errors.New("Arg x needs to be a ptr of struct")
		return
	}
	for i := 0;i < v.Elem().NumField() ;i++  {
		key := v.Elem().Field(i).Type().Name()
		value := v.Elem().Field(i).Interface()
		fmt.Printf("key: %v,value: %v\n",key,value)
	}
	return
}
```

当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。

#### 遍历字段

```go
type student struct {
	Name  string `json:"name"`
	Score int    `json:"score"`
}

func main() {
	stu1 := student{
		Name:  "小王子",
		Score: 90,
	}

	t := reflect.TypeOf(stu1)
	fmt.Println(t.Name(), t.Kind()) // student struct
	// 通过for循环遍历结构体的所有字段信息
	for i := 0; i < t.NumField(); i++ {
		field := t.Field(i)
		fmt.Printf("name:%s index:%d type:%v json tag:%v\n", field.Name, field.Index, field.Type, field.Tag.Get("json"))
	}

	// 通过字段名获取指定结构体字段信息
	if scoreField, ok := t.FieldByName("Score"); ok {
		fmt.Printf("name:%s index:%d type:%v json tag:%v\n", scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get("json"))
	}
}
```

#### 遍历值

```go
package main
import (
    "fmt"
    "reflect"
)
type person struct {
    name string
    age  int
}
func main() {
    v := reflect.ValueOf(person{"steve", 30})
    count := v.NumField()
    for i := 0; i < count; i++ {
        f := v.Field(i)
        switch f.Kind() {
        case reflect.String:
            fmt.Println(f.String())
        case reflect.Int:
            fmt.Println(f.Int())
        }
    }
}
```

```go
package main
 
import (
        "fmt"
        "reflect"
)
 
type User struct  {
        Id int
        Name string
        //addr string
}
 
func main(){
        u := User{Id:1001, Name:"xxx"/*, addr:"xxx"*/}
        t := reflect.TypeOf(u)
        v := reflect.ValueOf(u)
        for k := 0; k < t.NumFiled(); k++ {
                fmt.Printf("%s -- %v \n", t.Filed(k).Name, v.Field(k).Interface())   
        }
}
```

