# bufio — 缓存IO😐

![](F:\我的笔记\image\jdiasdjio.png)

bufio 包实现了缓存IO。它包装了 io.Reader 和 io.Writer 对象，创建了另外的Reader和Writer对象，它们也实现了 io.Reader 和 io.Writer 接口，不过它们是有缓存的。该包同时为文本I/O提供了一些便利操作，平时使用时我们不直接对文件进行读写操作，而是通过缓存来读写，这样速度更快，效率更高。



## Writer 类型和方法👘

bufio.Writer 结构包装了一个 io.Writer 对象，提供缓存功能，同时实现了 io.Writer 接口。

Writer 结构没有任何导出的字段，结构定义如下：

```go
    type Writer struct {
        err error        // 写过程中遇到的错误
        buf []byte       // 缓存
        n   int          // 当前缓存中的字节数
        wr  io.Writer    // 底层的 io.Writer 对象
    }
```

### 实例化

bufio 包提供了两个实例化 bufio.Writer 对象的函数：NewWriter 和 NewWriterSize。其中，NewWriter 函数是调用 NewWriterSize 函数实现的：

```go
    func NewWriter(wr io.Writer) *Writer {
        // 默认缓存大小：defaultBufSize=4096
        return NewWriterSize(wr, defaultBufSize)
    }
```

我们看一下 NewWriterSize 的源码：

```go
    func NewWriterSize(wr io.Writer, size int) *Writer {
        // 已经是 bufio.Writer 类型，且缓存大小不小于 size，则直接返回
        b, ok := wr.(*Writer)
        if ok && len(b.buf) >= size {
            return b
        }
        if size <= 0 {
            size = defaultBufSize
        }
        return &Writer{
            buf: make([]byte, size),
            wr:  w,
        }
    }
```

### Available 和 Buffered 方法

> Available 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）；
>
> Buffered 方法获取写入当前缓存中的字节数（字段 n 的值）。

```go
func (b *Writer) Available() int { return len(b.buf) - b.n }
func (b *Writer) Buffered() int { return b.n }
```

### Flush 方法

该方法将缓存中的所有数据写入底层的 io.Writer 对象中。使用 bufio.Writer 时，在所有的 Write 操作完成之后，应该调用 Flush 方法使得缓存都写入 io.Writer 对象中。

```go
func (b *Writer) Flush() error {
	if b.err != nil {
		return b.err
	}
	if b.n == 0 {
        //没有以缓存字段就返回。
		return nil
	}
	n, err := b.wr.Write(b.buf[0:b.n])
    //将以缓存字段写入io.write
	if n < b.n && err == nil {
        //没写全，并且没有发生错误
		err = io.ErrShortWrite
        //不完全写入。
	}
	if err != nil {
		if n > 0 && n < b.n {
			copy(b.buf[0:b.n-n], b.buf[n:b.n])
		}
		b.n -= n
		b.err = err
		return err
	}
	b.n = 0
	return nil
}
```

### Bufio.Writer本身的write方法

根据底层io.Writer实现者创建Bufio.Writer之后还需要填充缓存数据。

```go
func (b *Writer) Write(p []byte) (nn int, err error) {
	for len(p) > b.Available() && b.err == nil {
        //如果说没有可写入空间了（可写入空间不足。）
		var n int
		if b.Buffered() == 0 {
			// Large write, empty buffer.
			// Write directly from p to avoid copy.
			n, b.err = b.wr.Write(p)
		} else {
			n = copy(b.buf[b.n:], p)
			b.n += n
			b.Flush()
		}
		nn += n
		p = p[n:]
	}
	if b.err != nil {
		return nn, b.err
	}
	n := copy(b.buf[b.n:], p)
    //将数据写入缓存
	b.n += n
	nn += n
	return nn, nil
}
```

### 实例

```go
func writeItBufio(filename string){
	f,_ := os.Create(filename)
    //打开文件，返回*file对象.
	defer f.Close()
	writer := bufio.NewWriter(f)
	defer writer.Flush()
    //将缓存中数据冲入文件（调用了file的write方法）。
	for i:=0;i<10;i++ {
		fmt.Fprintln(writer,i)
        //向缓存中写入数据。
	}
}
```

