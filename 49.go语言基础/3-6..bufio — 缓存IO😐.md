# bufio — 缓存IO😐

![](F:\我的笔记\image\jdiasdjio.png)

bufio 包实现了缓存IO。它包装了 io.Reader 和 io.Writer 对象，创建了另外的Reader和Writer对象，它们也实现了 io.Reader 和 io.Writer 接口，不过它们是有缓存的。该包同时为文本I/O提供了一些便利操作，平时使用时我们不直接对文件进行读写操作，而是通过缓存来读写，这样速度更快，效率更高。

> [记住流程：]()
>
> `Reader`：将底层的`io.Reader`里的数据写入`bufio.Reader`中（此时调用`io.Reader.Read`），然后再读取到真正想要的字节数组中（此时调用`bufio.Reader.Read`）。
>
> `Writer`：将要写入底层`io.Writer`的数据先写入`bufio.Writer`中（此时调用`bufio.Reader.Writer`），然后再写入真正想要的底层Writer中（此时调用`bufio.Writer.Write`）。

## Writer 类型和方法👘

bufio.Writer 结构包装了一个 io.Writer 对象，提供缓存功能，同时实现了 io.Writer 接口。

Writer 结构没有任何导出的字段，结构定义如下：

```go
type Writer struct {
    err error        // 写过程中遇到的错误
    buf []byte       // 缓存
    n   int          // 当前缓存中的字节数
    wr  io.Writer    // 底层的 io.Writer 对象
}
```

### 实例化

bufio 包提供了两个实例化 bufio.Writer 对象的函数：NewWriter 和 NewWriterSize。其中，NewWriter 函数是调用 NewWriterSize 函数实现的：

```go
func NewWriter(wr io.Writer) *Writer {
    // 默认缓存大小：defaultBufSize=4096
    return NewWriterSize(wr, defaultBufSize)
}
```

我们看一下 NewWriterSize 的源码：

```go
func NewWriterSize(wr io.Writer, size int) *Writer {
    // 已经是 bufio.Writer 类型，且缓存大小不小于 size，则直接返回
    b, ok := wr.(*Writer)
    if ok && len(b.buf) >= size {
        return b
    }
    if size <= 0 {
        size = defaultBufSize
    }
    return &Writer{
        buf: make([]byte, size),
        wr:  w,
    }
}
```

### Available 和 Buffered 方法

> Available 方法获取缓存中还未使用的字节数（缓存大小 - 字段 n 的值）；
>
> Buffered 方法获取写入当前缓存中的字节数（字段 n 的值）。

```go
func (b *Writer) Available() int { return len(b.buf) - b.n }
func (b *Writer) Buffered() int { return b.n }
```

### Flush 方法

该方法将缓存中的所有数据写入底层的 io.Writer 对象中。使用 bufio.Writer 时，在所有的 Write 操作完成之后，应该调用 Flush 方法使得缓存都写入 io.Writer 对象中。

```go
func (b *Writer) Flush() error {
	if b.err != nil {
		return b.err
	}
	if b.n == 0 {
        //没有以缓存字段就返回。
		return nil
	}
	n, err := b.wr.Write(b.buf[0:b.n])
    //将以缓存字段写入io.write
	if n < b.n && err == nil {
        //没写全，并且没有发生错误
		err = io.ErrShortWrite
        //不完全写入。
	}
	if err != nil {
		if n > 0 && n < b.n {
			copy(b.buf[0:b.n-n], b.buf[n:b.n])
		}
		b.n -= n
		b.err = err
		return err
	}
	b.n = 0
	return nil
}
```

### Bufio.Writer本身的write和WriteString方法

根据底层io.Writer实现者创建Bufio.Writer之后还需要填充缓存数据。

```go
func (b *Writer) Write(p []byte) (nn int, err error) {
	for len(p) > b.Available() && b.err == nil {
        //如果说没有可写入空间了（可写入空间不足。）
		var n int
		if b.Buffered() == 0 {
			// Large write, empty buffer.
			// Write directly from p to avoid copy.
			n, b.err = b.wr.Write(p)
		} else {
			n = copy(b.buf[b.n:], p)
			b.n += n
			b.Flush()
		}
		nn += n
		p = p[n:]
	}
	if b.err != nil {
		return nn, b.err
	}
	n := copy(b.buf[b.n:], p)
    //将数据写入缓存
	b.n += n
	nn += n
	return nn, nil
}
```

```go
func (b *Writer) WriteString(s string) (int, error) {
	nn := 0
	for len(s) > b.Available() && b.err == nil {
		n := copy(b.buf[b.n:], s)
		b.n += n
		nn += n
		s = s[n:]
		b.Flush()
	}
	if b.err != nil {
		return nn, b.err
	}
	n := copy(b.buf[b.n:], s)
	b.n += n
	nn += n
	return nn, nil
}

```

### 实例

```go
func writeItBufio(filename string){
	f,_ := os.Create(filename)
    //打开文件，返回*file对象.
	defer f.Close()
	writer := bufio.NewWriter(f)
	defer writer.Flush()
    //将缓存中数据冲入文件（调用了file的write方法）。
	for i:=0;i<10;i++ {
		fmt.Fprintln(writer,i)
        //向缓存中写入数据。
	}
}
```



## Reader类型和方法👔

bufio.Reader对象，提供缓存功能，同时实现了 io.Raeder接口。

Writer 结构没有任何导出的字段，结构定义如下：

```go
type Reader struct {
	buf          []byte
	rd           io.Reader // reader provided by the client
	r, w         int       // buf read and write positions
	err          error
	lastByte     int // last byte read for UnreadByte; -1 means invalid
	lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid
}
```

### 实例化

bufio 包提供了两个实例化 bufio.Reader对象的函数：NewReader和 NewReaderSize。其中，NewReader函数是调用 NewReaderSize函数实现的：

```go
func NewReader(rd io.Reader) *Reader {
	return NewReaderSize(rd, defaultBufSize)
}
```

我们看一下 NewReaderSize的源码：

```go
func NewReaderSize(rd io.Reader, size int) *Reader {
	// Is it already a Reader?
	b, ok := rd.(*Reader)
	if ok && len(b.buf) >= size {
		return b
	}
	if size < minReadBufferSize {
		size = minReadBufferSize
	}
	r := new(Reader)
	r.reset(make([]byte, size), rd)
	return r
}
```

### Size 方法

> Size 方法获取写入当前缓存中的字节数
>

```go
func (b *Reader) Size() int { return len(b.buf) }
```

### Peek方法

从方法的名称可以猜到，该方法只是“窥探”一下 Reader 中没有读取的 n 个字节。好比栈数据结构中的取栈顶元素，但不出栈。

**签名：**

```go
func (b *Reader) Peek(n int) ([]byte, error)
```

**源码：**

```go
func (b *Reader) Peek(n int) ([]byte, error) {
    if n < 0 {
        return nil, ErrNegativeCount
    }

    b.lastByte = -1
    b.lastRuneSize = -1

    for b.w-b.r < n && b.w-b.r < len(b.buf) && b.err == nil {
        b.fill() // b.w-b.r < len(b.buf) => buffer is not full
    }

    if n > len(b.buf) {
        return b.buf[b.r:b.w], ErrBufferFull
    }

    // 0 <= n <= len(b.buf)
    var err error
    if avail := b.w - b.r; avail < n {
        // not enough data in buffer
        n = avail
        err = b.readErr()
        if err == nil {
            err = ErrBufferFull
        }
    }
    return b.buf[b.r : b.r+n], err
}
```

### Bufio.Reader本身的Read方法

根据底层io.Reader实现者创建Bufio.Reader之后还需要填充缓存数据，而填充缓存数据的过程就是从底层的reader里面读取数据。

```go
func (b *Reader) Read(p []byte) (n int, err error) {
	n = len(p)
	if n == 0 {
		if b.Buffered() > 0 {
			return 0, nil
		}
		return 0, b.readErr()
	}
	if b.r == b.w {
		if b.err != nil {
			return 0, b.readErr()
		}
		if len(p) >= len(b.buf) {
			// Large read, empty buffer.
			// Read directly into p to avoid copy.
			n, b.err = b.rd.Read(p)
			if n < 0 {
				panic(errNegativeRead)
			}
			if n > 0 {
				b.lastByte = int(p[n-1])
				b.lastRuneSize = -1
			}
			return n, b.readErr()
		}
		// One read.
		// Do not use b.fill, which will loop.
		b.r = 0
		b.w = 0
		n, b.err = b.rd.Read(b.buf)
		if n < 0 {
			panic(errNegativeRead)
		}
		if n == 0 {
			return 0, b.readErr()
		}
		b.w += n
	}

	// copy as much as we can
	n = copy(p, b.buf[b.r:b.w])
	b.r += n
	b.lastByte = int(b.buf[b.r-1])
	b.lastRuneSize = -1
	return n, nil
}
```

### 实例

```go
func readBufio(reader io.Reader) ([]byte,error) {
	br := bufio.NewReader(reader)
	line, err := br.Peek(100)
	fmt.Println(line)
	return line, err
}
```

