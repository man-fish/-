# Itetator接口（遍历器接口）

### 概念

> 这一章主要介绍for of 遍历原理。

```
  <!--
    概念： iterator是一种接口机制，为各种不同的数据结构提供统一的访问机制
    作用：
      1、为各种数据结构，提供一个统一的、简便的访问接口；
      2、使得数据结构的成员能够按某种次序排列
      3、ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。
    工作原理：
      - 创建一个指针对象(遍历器对象)，指向数据结构的起始位置。
      - 第一次调用next方法，指针自动指向数据结构的第一个成员
      - 接下来不断调用next方法，指针会一直往后移动，直到指向最后一个成员
      - 每调用next方法返回的是一个包含value和done的对象，{value: 当前成员的值,done: 布尔值}
        * value表示当前成员的值，done对应的布尔值表示当前的数据的结构是否遍历结束。
        * 当遍历结束的时候返回的value值是undefined，done值为false
    原生具备iterator接口的数据(可用for of遍历)
      1、Array
      2、arguments
      3、set容器
      4、map容器
      5、String
      。。。
  -->
      //for of		返回内容
      //for in		返回键
      //forEach		输出用
  -->for of和for in的原理不同：
     	for of		iteartor接口返回值判断
     	for in		复制一份数组
```

> 为什么对象（Object）没有部署Iterator接口呢？
>

**有两个原因：一是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。然而遍历遍历器是一种线性处理，对于非线性的数据结构，部署遍历器接口，就等于要部署一种线性转换。二是对对象部署Iterator接口并不是很必要，因为Map弥补了它的缺陷，又正好有Iteraotr接口。**

### 模拟Iterator接口

```js
       function Iterator(arr){
                let nextIndex = 0
                return {
                    next:function(){
                        return nextIndex<arr.length?{value:arr[nextIndex++],done:false}:{value:undefined,done:true}
                    }
                }
            }
```

### 强行使用Iterator接口for of循环遍历对象

```js
Obj.prototype[Symbol.iterator]=function(){
	var iterator={next:next};
	var current=this;
	function next(){
		if(current){
			var value=current.value;
			var done=current.next===null;
			current=current.next;
			return {
				value:value,
				done:done
			};
		}else{
			return {done:true};
		}
	}
	return iterator;
```

