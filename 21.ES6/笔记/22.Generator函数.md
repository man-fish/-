# Generator 生成器函数

### 概念

```html
  <!--
   Generator函数
    概念：
      1、ES6提供的解决异步编程的方案之一
      2、Generator函数是一个状态机，内部封装了不同状态的数据，
      3、用来生成遍历器对象
      4、可暂停函数(惰性求值), yield可暂停，next方法可启动。每次返回的是yield后的表达式结果
    特点：
      1、function 与函数名之间有一个星号
      2、内部用yield表达式来定义不同的状态
      例如：
        function* generatorExample(){
          let result = yield 'hello';  // 状态值为hello
          yield 'generator'; // 状态值为generator
        }
      3、generator函数返回的是指针对象(接11章节里iterator)，而不会执行函数内部逻辑
      4、调用next方法函数内部逻辑开始执行，遇到yield表达式停止，返回{value: yield后的表达式结果/undefined, done: false/true}
      5、再次调用next方法会从上一次停止时的yield处开始，直到最后
      6、yield语句返回结果通常为undefined， 当调用next方法时传参内容会作为启动时yield语句的返回值。
  -->
```

### 详解

1.生成器函数可以用for - of 遍历但是只能获取yield后面的函数体或者对象，变量，不会执行函数的实际效果。

```js
function* foo(){
	yield 1
	yield function(){console.log(1)}
}
for(let item of foo){
	console.log(item)	//1		//function(){} 
}
```

2.可以通过给.next传入参数来使yield后面的语句有返回值，可以在前面用变量接受。

```js
function* foo(){
	let back = yield 1
	console.log(back)
}
foo().next("传入返回值")
```

3.next没有执行函数的作用，所以要有调用。

```js
function* foo(){
	yield function(){console.log(1)}
	yield function(){console.log(1)}()
}
GM.next()	//无输出
GM.next()	//1
```

4.通过Generator生成器来给obj一个遍历器接口。

需要遍历器接口的函数或者操作符，会先检测对象身上的Symbol.iterator接口，如果有，则遍历。

```js
 let obj = {
     name:"jack",
     age:6
 }
 obj[Symbol.iterator] = function* (){
         yield 1
         yield 2
 }

 for(let item of obj){
     console.log(item)
 }
```

### 使用

```js
function Console(txt){
    console.log(txt)
}

function* myGenerator(){
        Console("第一次开始执行")
        yield 'hello'
        Console("暂停之后继续执行")
        yield 'generator'
        return '放回的结果'
        Console("return之后就不会执行了")
        yield 'endend'
        // yield function(){
        //     console.log()
        // }
}

let MG = myGenerator()

console.log(MG.next())
console.log(MG.next())
```

### 来讲解一下参数的传递过程：

```js
    $(function(){
        function first(data){
            console.log("第一个函数执行了")
            setTimeout(()=>{
                GM.next(data)
                //传入
            },1000)
        }
        function second(content){
            console.log("第二个函数执行了")
            console.log(content)
        }
        function* myGenerator(){
            let cnon = yield first("hahahahhah");
//GM.next(参数)，如果其执行的语句是类似上面的let cnon = yield fn()则将参数传给fn作为其返回值被cnon接收。
            yield second(cnon)
        }

        let GM = myGenerator()
        GM.next()
    }())
```

```js
    $(function(){
        function getNews(){
                setTimeout(function(){
                    console.log("第一个定时器结束")
                    let url = "第二个定时器结束"
                    GM.next(url)
                },1000)
                //这里如果不是一个异步的任务就会报Generator is running！的错误。
        }

        function getCmt(url){
            setTimeout(function(){
                    console.log(url)
            },1000)
        }

        function* getMsg(){
            console.log("请求文章")
            let url = yield getNews()
            console.log("请求评论")
            yield getCmt(url)
        }

        let GM = getMsg()
        
        $("button").click(()=>{
            GM.next()
        })
    })
```

