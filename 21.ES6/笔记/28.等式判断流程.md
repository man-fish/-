## `===`运算符判断相等的流程是怎样的

1. 类型不同，不等
2. `null，undefined，boolean，number`这四个类型的只要值(数值)相等，就相等，`-0 === 0 //true`
3. 只要其中有一个为`NAN`，则不等
4. string类型，长度/内容/编码不同，都是不等，相同位置包含相同的16位，相等
5. 指向相同的对象，数组，函数，则相等，若指向不同对象，不等

## `==`运算符判断相等的流程是怎样的

1. 类型不同，则启用隐式类型转换

   - 有`NAN`，一律返回`false`
   - 有布尔类型，布尔类型转换成数字比较
   - 有string类型，两种情况： 1. 对象，对象用`toString`方法转换成string相比。2.数字，string类型转换成数字进行比较

   ```js
   let a = {}
   obj.toString()  //"[Object object]"
   "[Object object]" == a
   0 == “0”
   ```

   - null和undefined不会相互转换，相等
   - 有数字类型，和对象相比，对象用`valueof`转换成原始值进行比较

   ```js
   const a = new Number(1)
   a.valueOf() // 1
   a == 1
   ```

   - 其他情况，一律返回`false`

   ## NaN为什么不等于NaN

   在JS中 Object === Object 感觉没有任何问题 这两个都代表的一个东西

   但是如果你试过 NaN === NaN 是返回false为什么呢?

   因为NaN 是:Not a number (不是一个数字的缩写)

   既然不是一个数字 那么很好理解 'A'不是一个数字 ,'B'也不是一个数字

   那么既然他们两个都不是数字 ,难道'A' === 'B'吗? 显然不是

   