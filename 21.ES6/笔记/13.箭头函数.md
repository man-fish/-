# 箭头函数

```javascript
/**
  * 箭头函数
  */
	( window => {
			let eat = ()=> console.log("吃吃吃吃")
			//定义参数eat
			let out = fn => fn
			//这里只有一个参数括号可以省略，后面只有一行且没有括号则直接返回fn
			window.eat = out(eat)
	})(window)
	eat()
```

> 括号函数的缺点是不能赋予函数名。

```javascript
/**
  * 箭头函数this
  * 不再是当前的意思
  *	有外层函数的时候this就是外层函数的this。
  * 没有外层函数的时候就是window。
  * 外层函数还是箭头函数时就继续向外找。
  */
	let btn1 = document.getElementById('btn1')
	let btn2 = document.getElementById('btn2')
	let btn3 = document.getElementById('btn3')
	let btn4 = document.getElementById('btn4')
	btn1.onclick = function(){
		console.log(this)
	}
	btn2.onclick = ()=>{
		console.log(this)
	}
	var obj = {
		Onormal : function(){
			btn3.onclick = () => {
				console.log(this)
			}
		},
		//外层函数的this是obj，内层函数的this就是obj
		Oarrow : ()=>{
			btn4.onclick = ()=>{
				console.log(this)
			}
		}
		//外层函数也是括号函数的时候，就去找外层函数的this指向
		//外层函数没有外层函数，外层函数的this就是window，所以内层函数的this也是window
	}
	obj.Onormal();
	obj.Oarrow();
```

箭头函数出来之前，函数在执行时才能确定 `this` 的指向，所以会经常出现闭包中的 `this` 指向不是期望值的情况。在以前的做法中，如果要给闭包指定 `this`，可以用 `bind\call\apply`，或者把 `this` 值分配给封闭的变量（一般是 `that`）。箭头函数出来之后，给我们提供了不一样的选择。

箭头函数不会创建自己的 `this`，只会从自己定义位置的作用域的上一层直接继承 `this`。

```javascript
function Person(){
  this.age = 10;

  setInterval(() => {
    this.age++;    // this 正确地指向 p 实例
  }, 1000);
}

var p = new Person();  // 1s后打印出 10
```

另外因为箭头函数没有自己的 `this` 指针，因此对箭头函数使用 `call`、`apply`、`bind` 时，只能传递函数，不能绑定 `this`，它们的第一个参数将被忽略：

```javascript
this.param = 1

const func1 = () => console.log(this.param)
const func2 = function() {
    console.log(this.param)
}
func1.apply({ param: 2 })   // 输出: 1
func2.apply({ param: 2 })   // 输出: 2
```

总结一下：

1. 箭头函数中的 `this` 就是**定义时所在的对象**，而不是使用时所在的对象；
2. 无法作为构造函数，不可以使用 `new` 命令，否则会抛错；
3. 箭头函数中不存在 `arguments` 对象，但我们可以通过 Rest 参数来替代；
4. 箭头函数无法使用 `yield` 命令，所以不能作为 Generator 函数；
5. 不可以通过 `bind`、`call`、`apply` 绑定 `this`，但是可以通过 `call`、`apply` 传递参数。

