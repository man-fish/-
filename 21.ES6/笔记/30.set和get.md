# [js对象的 set 和 get 用法](<https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get>)

### 优点

Getters 给你一种方法来定义一个对象的属性，但是在访问它们之前不会计算属性的值。 getter 延续计算值的成本，直到需要值，如果不需要，您就不用支付成本。

一种额外的优化技术是用**智能或记忆化 getters** 延迟属性值的计算并将其缓存以备以后访问。该值是在第一次调用getter 时计算的，然后被缓存，因此后续访问返回缓存值而不重新计算它。这在以下情况下很有用：

- 如果属性值的计算是昂贵的（占用大量RAM或CPU时间，产生工作线程，检索远程文件等）。
- 如果现在不需要该值。它将在稍后使用，或在某些情况下它根本不使用。
- 如果被使用，它将被访问几次，并且不需要重新计算该值将永远不会被改变，或者不应该被重新计算。

这意味着你不应该为你希望更改其值的属性使用懒 getter，因为 getter 不会重新计算该值。

在以下示例中，对象具有一个 getter 属性。在获取属性时，该属性将从对象中删除并重新添加，但此时将隐式显示为数据属性。最后返回得到值。

### 描述

有时需要允许访问返回动态计算值的属性，或者你可能需要反映内部变量的状态，而不需要使用显式方法调用。在JavaScript中，可以使用 *getter* 来实现。虽然可以使用 getter 和 setter 来创建一个伪属性类型，但是不可能同时将一个 getter 绑定到一个属性并且该属性实际上具有一个值。

使用`get`语法时应注意以下问题：

- 可以使用数值或字符串作为标识；
- 必须不带参数（请参考[Incompatible ES5 change: literal getter and setter functions must now have exactly zero or one arguments](http://whereswalden.com/2010/08/22/incompatible-es5-change-literal-getter-and-setter-functions-must-now-have-exactly-zero-or-one-arguments/)）；
- 它不能与另一个 `get `或具有相同属性的数据条目同时出现在一个对象字面量中（不允许使用 `{ get x() { }, get x() { } }` 和 `{ x: ..., get x() { } }`）。

可通过 `delete` 操作符删除 getter。

### 在初始化对象的时候这样使用

```js
var obj={
    a: 1,
    b: 2,
    set c(x){console.log('c被赋值：',x);c=x;},
    get c(){console.log('c被取出: ',c);return c}  
};

obj.c=3  //c被赋值： 3
obj.c  //c被取出:  3
```

这样可以对要设置的属性预处理（统一处理），set c( )就相当于定义属性c

当你不使用默认的c时

### 当然也可以这样和definePro...连用

```js
Object.defineProperty(obj, c, {
　　set:function(x){
　　　　console.log('c被赋值：',x);
　　　　c=x
　　},
　　get:function(){
　　　　console.log('c被取出：',c)
　　　　return c
　　}
})
obj.c=3  //c被赋值： 3
obj.c  //c被取出:  3
```

此时get和set必须连用。

```js
    Object.defineProperties(obj2,{
        full :{
            get:function(){
                return this.first+" "+this.end
            },
            set:function(data){
                var datalist = data.split(" ")
                this.first = datalist[0]
                this.end = datalist[1]
                // first和end和full都会改变
            }
        }
    })
    obj2.full = '陈宇 罗燕'   //无法修改
```

**需要注意的是set里面的函数修改的值（其他变量）都会生效。**

### 类的用法

注意这个方法不加static是一个实例方法。

```js
class EggCore extends KoaApplication {
    constructor(options) {
        ......
    }
    .....
    
    get router() {
        if (this[ROUTER]) {
          return this[ROUTER];
        }
        const router = this[ROUTER] = new Router({ sensitive: true }, this);
        // register router middleware
        this.use(router.middleware());
        return router;
      }
      
   ...
}
```

```js
var obj = {
  log: ['a', 'b', 'c'],
  get latest() {
    if (this.log.length == 0) {
      return undefined;
    }
    return this.log[this.log.length - 1];
  }
}

console.log(obj.latest);
// expected output: "c"
```

```js
class C{
    static get c(){
		return 1
    }
}

C.c		//1
```

