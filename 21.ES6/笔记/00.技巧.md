# 技巧

## 类型

### 1.1 短路运算符

我们知道逻辑与`&&`与逻辑或`||`是短路运算符，短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了； 可以理解为：

- `&&`为取假运算，从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值
- `||`为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值

```js
let param1 = expr1 && expr2
let param2 = expr1 || expr2
复制代码
```

| 运算符 | 示例           | 说明                                                         |
| ------ | -------------- | ------------------------------------------------------------ |
| `&&`   | `expr1&&expr2` | 如果expr1 能转换成false则返回expr1,否则返回expr2. 因此, 在Boolean环境中使用时, 两个操作结果都为true时返回true,否则返回false. |
| \|\|   | expr1\|\|expr2 | 如果expr1能转换成true则返回expr1,否则返回expr2. 因此,在boolean环境(在if的条件判断中)中使用时, 二者操作结果中只要有一个为true,返回true;二者操作结果都为false时返回false. |
| `!`    | `!expr`        | 如果单个表达式能转换为true的话返回false,否则返回true.        |

因此可以用来做很多有意思的事，比如给变量赋初值：

```js
let variable1
let variable2 = variable1  || 'foo'
复制代码
```

如果variable1是真值就直接返回了，后面短路就不会被返回了，如果为假值，则会返回后面的`foo`。

也可以用来进行简单的判断，取代冗长的`if`语句：

```js
let variable = param && param.prop
复制代码
```

如果`param`如果为真值则返回`param.prop`属性，否则返回`param`这个假值，这样在某些地方防止`param`为`undefined`的时候还取其属性造成报错。

##### 判断是否传入回调参数：

```js
function a(b){
        b&&b()
}
```

### 1.2 string和数字类型之间的强制转化

可以用`*1`来转化为数字(实际上是调用`.valueOf`方法) 然后使用`Number.isNaN`来判断是否为`NaN`，或者使用 `a !== a` 来判断是否为`NaN`，因为 `NaN !== NaN`

```js
'32' * 1            // 32
'ds' * 1            // NaN
null * 1            // 0
undefined * 1    // NaN
1  * { valueOf: ()=>'3' }        // 3
复制代码
```

**常用：** 也可以使用`+`来转化字符串为数字

```js
+ '123'            // 123
+ 'ds'               // NaN
+ ''                    // 0
+ null              // 0
+ undefined    // NaN
+ { valueOf: ()=>'3' }    // 3
```

### 1.3 使用Boolean过滤数组中的所有假值

我们知道JS中有一些假值：`false`，`null`，`0`，`""`，`undefined`，`NaN`，怎样把数组中的假值快速过滤呢，可以使用Boolean构造函数来进行一次转换

```
const compact = arr => arr.filter(Boolean)
compact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34])             // [ 1, 2, 3, 'a', 's',
```

### 1.4 双位运算符 ~~

可以使用双位操作符来替代正数的 `Math.floor( )`，替代负数的`Math.ceil( )`。双否定位操作符的优势在于它执行相同的操作运行速度更快。

```js
Math.floor(4.9) === 4      //true
// 简写为：
~~4.9 === 4      //true
复制代码
```

不过要注意，对正数来说 `~~` 运算结果与 `Math.floor( )` 运算结果相同，而对于负数来说与`Math.ceil( )`的运算结果相同：

```js
~~4.5                // 4
Math.floor(4.5)      // 4
Math.ceil(4.5)       // 5

~~-4.5        		// -4
Math.floor(-4.5)     // -5
Math.ceil(-4.5)      // -4
```

### 1.6 取整 `| 0`

对一个数字`| 0`可以取整，负数也同样适用，`num | 0`

```
1.3 | 0         // 1
-1.9 | 0        // -1
```

### 1.7 判断奇偶数 `& 1`

对一个数字`& 1`可以判断奇偶数，负数也同样适用，`num & 1`

```js
const num=3;
!!(num & 1)                    // true
!!(num % 2)                    // true
```

## 函数

### 参数

#### 2.1 函数默认值

```
func = (l, m = 3, n = 4 ) => (l * m * n);
func(2)             //output: 24
复制代码
```

#### 2.2 强制参数

默认情况下，如果不向函数参数传值，那么JS 会将函数参数设置为`undefined`。其它一些语言则会发出警告或错误。要执行参数分配，可以使用`if`语句抛出未定义的错误，或者可以利用`强制参数`。

```js
mandatory = ( ) => {
  throw new Error('Missing parameter!');
}
foo = (bar = mandatory( )) => {     // 这里如果不传入参数，就会执行manadatory函数报出错误
  return bar;
}
```

### 函数内部对函数进行修改

#### 2.3 惰性载入函数

在某个场景下我们的函数中有判断语句，这个判断依据在整个项目运行期间一般不会变化，所以判断分支在整个项目运行期间只会运行某个特定分支，那么就可以考虑惰性载入函数

```js
function foo(){
    if(a !== b){
        console.log('aaa')
    }else{
        console.log('bbb')
    }
}
 
// 优化后
function foo(){
    if(a != b){
        foo = function(){
            console.log('aaa')
        }
    }else{
        foo = function(){
            console.log('bbb')
        }
    }
    return foo();
}
复制代码
```

那么第一次运行之后就会覆写这个方法，下一次再运行的时候就不会执行判断了。当然现在只有一个判断，如果判断很多，分支比较复杂，那么节约的资源还是可观的。

#### 2.4 一次性函数

跟上面的惰性载入函数同理，可以在函数体里覆写当前函数，那么可以创建一个一次性的函数，重新赋值之前的代码相当于只运行了一次，适用于运行一些只需要执行一次的初始化代码

```js
var sca = function() {
    console.log('msg')
    sca = function() {
        console.log('foo')
    }
}
sca()        // msg
sca()        // foo
sca()        // foo
```

## 3. 字符串

### 3.1 字符串比较时间先后

比较时间先后顺序可以使用字符串：

```js
var a = "2014-08-08";
var b = "2014-09-09";
 
console.log(a>b, a<b); // false true
console.log("21:00"<"09:10");  // false
console.log("21:00"<"9:10");   // true   时间形式注意补0
复制代码
```

因为字符串比较大小是按照字符串从左到右每个字符的`charCode`来的，但所以特别要注意时间形式注意补0

