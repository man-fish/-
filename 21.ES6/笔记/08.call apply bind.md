# call apply bind

## 实际作用

```html
<script>
    ///Function
    var obj = {name:'wangbo'}
    function consol(data){
        console.log(this+data)
    }
    consol.call(obj)
    consol.apply(obj,[33])//apply和call在调用的时候会更改this指向
    consol.bind(obj,44)()//bind会返回一个更改了this指向的函数

    console.log(Object.prototype.toString.call(String,555))
    console.log((111).toString())

    setTimeout(function(){
        console.log(this)
    }.bind(obj),1000)//bind一般用于计时器传this
</script>
```

## Function.prototype.call(   )

函数实例的`call`方法，可以指定函数内部`this`的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。

```javascript
var obj = {};

var f = function () {
  return this;
};

f() === window // true
f.call(obj) === obj // true
```

上面代码中，全局环境运行函数`f`时，`this`指向全局环境（浏览器为`window`对象）；`call`方法可以改变`this`的指向，指定`this`指向对象`obj`，然后在对象`obj`的作用域中运行函数`f`。	

`call`的第一个参数就是`this`所要指向的那个对象，后面的参数则是函数调用时所需的参数。

```javascript
function add(a, b) {
  return a + b;
}

add.call(this, 1, 2) // 3
```

这个就是吧Atom的属性绑定再Mota之中。

```javascript
    function Atom(name,age){
        this.name = name;
        this.age = age;
    }
    Atom.prototype.console = function(){
      console.log(this);
    }
  }
  function Mota(name,age,id){
      Atom.call(this,name,age)
  }
```

## Function.prototype.apply(  )

`apply`方法的作用与`call`方法类似，也是改变`this`指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。

```javascript
func.apply(thisValue, [arg1, arg2, ...])	
```

**（1）找出数组最大元素**

JavaScript 不提供找出数组最大元素的函数。结合使用`apply`方法和`Math.max`方法，就可以返回数组的最大元素。

```
var a = [10, 2, 4, 15, 9];
Math.max.apply(window, a) // 15
```

**（2）将数组的空元素变为undefined**

通过`apply`方法，利用`Array`构造函数将数组的空元素变成`undefined`。

```
Array.apply(null, ['a', ,'b'])
// [ 'a', undefined, 'b' ]
```

## Function.prototype.bind(  ) 

`bind`方法用于将函数体内的`this`绑定到某个对象，然后返回一个新函数。

```javascript
var d = new Date();
d.getTime() // 1481869925657

var print = d.getTime;
print() // Uncaught TypeError: this is not a Date object.
```

上面代码中，我们将`d.getTime`方法赋给变量`print`，然后调用`print`就报错了。这是因为`getTime`方法内部的`this`，绑定`Date`对象的实例，赋给变量`print`以后，内部的`this`已经不指向`Date`对象的实例了。

`bind`方法可以解决这个问题。

```javascript
var print = d.getTime.bind(d);
print() // 1481869925657
```

```javascript
var counter = {
  count: 0,
  inc: function () {
    this.count++;
  }
};

var func = counter.inc.bind(counter);
```

#### bind和call的区别 ：

```javascript
var counter = {
  count: 0,
  inc: function () {
    this.count++;
  }
};
var func = counter.inc.bind(counter);
var fun = counter.call()完全不能到效果
```

由此我们可以看出，call是在执行的时候更改指向，而bind是储存。