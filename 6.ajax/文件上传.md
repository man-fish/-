## AJax的文件上传和新对象

### FormData对象

> FormData 就是 XMLHttpRequest Level 2 新增的一个对象，利用它来提交表单、[模拟](https://www.baidu.com/s?wd=%E6%A8%A1%E6%8B%9F&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)表单提交，当然最大的优势就是可以上传二进制文件。解决上传中的问题，使用ajax的方式上传文件域最重要的就是获取数据，这时我们就可以使用HTML5的from-data他的作用是获取表单的数据，和post方法连用

1.最基础的使用方法：

> 可以把所有表单元素的name与value组成一个queryString，提交到后台。只需要把 form 表单作为参数传入 FormData 构造函数即可：

```javascript
var form = document.getElementById("form1");
var fd = new FormData(form);
```

> 和原生XMLHttpRequest连用

```javascript
function fsubmit() {
    var form=document.getElementById("form1");
    var formData=new FormData(form);
    var oReq = new XMLHttpRequest();
    oReq.open("POST", "server.php");
    oReq.send(formData);  	//就不需要再使用urlencode格式的复杂转换了
    oReq.onreadystatechange=function(){
      if(oReq.readyState==4){
        if(oReq.status==200){
		//this.readystate就是指状态，不论成功与否哦
        }
      }
    };
    return false;
}
```

2.正常post请求对比

```javascript
var xhr = new XMLHttpRequest()
// open 方法的第一个参数的作用就是设置请求的 method
xhr.open('POST', './add.php')
// 设置请求头中的 Content‐Type 为 application/x‐www‐form‐urlencoded
// 标识此次请求的请求体格式为 urlencoded 以便于服务端接收数据
减少了以下两行代码。
xhr.setRequestHeader('Content‐Type', 'application/x‐www‐form‐urlencoded')
// 需要提交到服务端的数据可以通过 send 方法的参数传递
// 格式：key1=value1&key2=value2
xhr.send('key1=value1&key2=value2')
xhr.onreadystatechange = function () {
if (this.readyState === 4) {
console.log(this.responseText)
}
}
```

> 反正虽然这个对象不知道为什么可以不去规定post方式的请求头设置，反正就是可以。

3.和ajax连用

```javascript
function fsubmit() {
        var form=document.getElementById("form1");
        var fd =new FormData(form);
        $.ajax({
             url: "server.php",
             type: "POST",
             data: fd,
             processData: false,  // 告诉jQuery不要去处理发送的数据
             contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
             success: function(response,status,xhr){
             
             }
        });
        return false;
    }
```

> 参数过多还不如原生的简单，不过从传入data的角度来看，这个formdata对象是一种很奇妙的东西反正就是可以上传数据。

4.对象方法介绍

> 方法用于向 FormData 对象中添加，修改，删除键值对
>
> 应用场景：在想要单独处理表单的一部分文件时。

```javascript
-----追加
fd.append('key1',"value1");
fd.append('key2',"value2");
-----删除
fd.append('name','will');
fd.delete('name');
-----设置
fd.set('key1',"value1");
fd.set('key2',"value2");
```

------

### 最基本的文件域

> 地址的指向没的说，文件上传的方式必须是post因为上传文件时一般是以二进制的形式上传，（通过报文），而且表单后面要声明传输的方式multipart/form-data,
>
> Enctyle：编码方式。
>
> Form-data ：一种传输方式
>
> Multipart:分包的意思，也可以指上传的数据由字符串和而二进制组成。
>
> Binary二进制数据。	

```php+HTML
	<form action="<?php echo $_SERVER['PHP_SELF']; ?>" method="post" enctype="multiple/form-data">
		<input type="file" name="avatar" id="avatar">
		<!-- <input type="hidden" name="position"> -->
		<input type="submit" value="提交">
		<img src="<?php echo isset($SRC)? $SRC : $GLOBALS['SRC'];?>" alt="">
	</form>
```

1.如何使用异步方式上传图片

> 表单的提交是同步，那么我们如何使用ajax的方式来提交文件域呢，我们要用到dom里面的files属性和formdata对象来配合。

> 　File API在表单中的文件输入字段的基础上，又添加了一些直接访问文件信息的接口。HTML5在DOM中为文件输入元素添加了一个files集合。在通过文件输入字段选择了一或多个文件时，files集合中将包含一组File对象，每个File对象对应着一个文件。
>
> 每个File对象都有下列只读属性
>
> 　　name:本地文件系统中的文件名
>
> 　　size:文件的字节大小
>
> 　　type:字符串，文件的MIME类型
>
> 　　lastModifiedDate:字符串，文件上一次被修改的时间
>
> 　　通过侦听change事件可以很好的判断文件是否被选择（和input：file很好的配合），并读取files集合就可以知道选择的每个文件的信息

```javascript
      $('#logo').on('change',function(){
        var files =$(this).prop('files');
        if(!files.length)return;
        var file = files[0];

        var data = new FormData();
        data.append('avatar',file);
      })
```

#### 接下来问题分为了两个方向：后台的逻辑和前台的图片式文件域。

##### 后台的逻辑：

```php
function upload () {
  var_dump($_FILES);
  if (!isset($_FILES['avatar'])) {
    $GLOBALS['message'] = '别玩我了';
    // 客户端提交的表单内容中根本没有文件域
    return;
  }

  $avatar = $_FILES['avatar'];
    -------------------------------$_FILES['avatar']对象的构成---------------------------------
  $avatar => array(5) {
    ["name"]=>
    string(11) "icon-02.png"
    ["type"]=>
    string(9) "image/png"
    ["tmp_name"]=>
    string(27) "C:\Windows\Temp\php1138.tmp"
    ["error"]=>
    int(0)
    ["size"]=>
    int(4398)
  }
    ------------------------------------------------------------------------------------------
  echo $avatar['error'];
  if ($avatar['error'] !== UPLOAD_ERR_OK) {
    // 服务端没有接收到上传的文件
    $GLOBALS['message'] = '上传失败';
    return;
  }
  //  2. 校验上传文件的类型（type）
  $allowed_source_types = array('audio/mp3', 'audio/wma');
  if (!in_array($_FILES['source']['type'], $allowed_source_types)) {
    $GLOBALS['error_type'] = 'source';
    $GLOBALS['error_msg'] = "只能上传音频文件";
    return;
  }

  //  3. 校验文件大小（size）文件的大小单位是字节
  if (1 * 1024 * 1024 > $_FILES['source']['size'] || $_FILES['source']['size'] > 10 * 1024 * 1024) {
    $GLOBALS['error_type'] = 'source';
    $GLOBALS['error_msg'] = "上传文件大小不合理";
    return;
  }
    
  // 接收到了文件
  // 将文件从临时目录移动到网站范围之内
  $source = $avatar['tmp_name']; // 源文件在哪
  // => 'C:\Windows\Temp\php1138.tmp'
  $target = './uploads/' . $avatar['name']; // 目标放在哪
  // => './uploads/icon-02.png'
  // 移动的目标路径中文件夹一定是一个已经存在的目录
  $moved = move_uploaded_file($source, $target);

  if (!$moved) {
    $GLOBALS['message'] = '上传失败';
    return;
  }
  // 移动成功（上传整个过程OK）
}
```

> 很简单

#### 总结刚刚的方式

> 如果是使用刚刚的异步文件上传的方式，那就是先单独为图片进行一次ajax请求，之后服务端返回一个地址，我们用一个隐藏的input：hidden把数据存到上面，在提交表单的时候把已经上传的图片的地址存到数据库里。

代码：	

```php
<?php 
if(empty($_FILES['avatar'])){
	exit('请上传文件');
}

$avatar = $_FILES['avatar'];

if($avatar['error'] != UPLOAD_ERR_OK){
	exit('上传失败');
}

$ext = pathinfo($avatar['name'],PATHINFO_EXTENSION);

$target = '../../static/uploads/img-'.uniqid().'.'.$ext;
								//为图片生成一个随机（用不重复）的id值来重命名上传的文件。
if(!move_uploaded_file($avatar['tmp_name'],$target)){

	exit('上传失败');

}
echo substr($target, 5);
 ?>
```
