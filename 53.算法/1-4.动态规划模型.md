## 线性模型

**两个变量之间存在一次方函数关系，就称它们之间存在线性关系。**在线性结构上进行状态转移DP，统称线性DP，注意问题中的未知数只有两个那就是n和f(n)，比如说分金币问题中的coins总数和charge次数。下面拿实际问题来举例子。

**注意**：已知量数组不属于变量，比如说金币面额。

### 	切木棍

### lis

### lcs

## 区间模型

所谓区间dp，顾名思义就是在一段区间上的动态规划。它既要满足dp问题的最优子结构和无后效性外，还应该符合在区间上操作的特点。我的理解是往往会对区间进行合并操作。抑或是单个元素（可看成一个小区间）跨区间进行操作。例如括号匹配问题，石子合并问题（通过多次的相邻合并，最后实质上会产生跨区间的合并，如果你把其中的石子看作参考系的话就很容易感觉出来），还有在整数中插入运算符号的问题（利用运算符的优先级以及交换律可看出），这样以来，如果我们要得知一个大区间的情况，由于它必定是由从多个长度不一的小区间转移而来（转移情况未知），我们可以通过求得多个小区间的情况，从而合并信息，得到大区间。

**对于一个长度为n的区间，确定它的子区间需要首尾两个指针，显然子区间数量级为n2，那区间dp的复杂度也就为n2**

### 范式

```go
for len := 2; len <= n; len++  {		/* 区间长度，在这道题里指的就是第1个到第n个。 */
    for i := 0; i < n ; i++  {			/* 枚举起点，从1开始到n，i表示起点下标，j表示终点下标， */
        j := i + len -1					/* 计算终点坐标 */
        if j >= n {						/* 省去越界的部分 */
            continue
        }
        for k := i; k < j ; k++  {		/* 枚举区间分割点 */
            //do something
        }
    }
}
```

### 石子合并问题

有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。

#### 动态转移方程

$$
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+w[i][j]);
$$

#### 递归穷举解决

递归的方法我们通过动态转移方程和容易就能写出来，不过这里我们要注意我注释的部分。

```go
func mergeStoneRecursive(sum []int, i, j int) int {
	if i == j {
		return 0
	}

	if j == i + 1 {
		return sum[j+1] - sum[i]
	}

	bestChoice := math.MaxInt64

	for k := i+1; k < j ; k++ {
		l := mergeStoneRecursive(sum,i,k-1) + mergeStoneRecursive(sum,k,j) + sum[j+1] - sum[i]
		r := mergeStoneRecursive(sum,i,k) + mergeStoneRecursive(sum,k+1,j) + sum[j+1] - sum[i]
		cbs := int(math.Min(float64(l),float64(r)))
		// 就以2，3，1为例，先合并2和3与先合并3和1的结果是不同的我们要取最小值。
		bestChoice = int(math.Min(float64(cbs),float64(bestChoice)))
	}

	if bestChoice == math.MaxInt64 {
		return 0
	}else{
		return bestChoice
	}
}
```

#### 备忘录优化

如上文所说区间dp的数组是二维关于i和j的。

```go
func mergeStoneRecursiveMemorized(sum []int, memory [][]int, i, j int) int {
   if i == j {
      return 0
   }

   if memory[i][j] != 0 {
      return memory[i][j]
   }

   if j == i + 1 {
      memory[i][j] = sum[j+1] - sum[i]
      return memory[i][j]
   }

   bestChoice := math.MaxInt64

   for k := i+1; k < j ; k++ {
      l := mergeStoneRecursiveMemorized(sum,memory,i,k-1) + mergeStoneRecursiveMemorized(sum,memory,k,j) + sum[j+1] - sum[i]
      r := mergeStoneRecursiveMemorized(sum,memory,i,k) + mergeStoneRecursiveMemorized(sum,memory,k+1,j) + sum[j+1] - sum[i]
      cbs := int(math.Min(float64(l),float64(r)))
      bestChoice = int(math.Min(float64(cbs),float64(bestChoice)))
   }

   if bestChoice == math.MaxInt64 {
      return 0
   }else{
      memory[i][j] = bestChoice
      return bestChoice
   }
}
```

#### 动态规划解决

设计动态规划写法之前，我们先分析一下上文的备忘录的结构。

![考场案件管理](F:\我的笔记\53.算法\assets\考场案件管理.png)

首先`i==j`时，合并次数为`0`，`j<i`时合并次数为`0`，`j = j+1`时合并次数为`sum[j]-sum[i-1]`，我更倾向于让数组最外面留一层作为初始值，所以i的下标从`1`开始，但是实际上区间是没有必要多出一圈的。

```go
func mergeStone(n int,w []int) int   {
	dp := make([][]int,n+1)
	for  i := 0; i < n+1 ; i ++  {
		dp[i] = make([]int,n+1)
	}
	/*声明dp数组*/
	sum := make([]int, n+1)
	for idx := 1; idx < len(sum); idx++ {
		for i := 1; i <= idx ; i++  {
			sum[idx] += w[i-1]
		}
	}
	/*计算组合石头花费（从0开始，0表示没有石头）*/
	for len := 2; len < n+1; len++  {		/* 区间长度，在这道题里指的就是第1个到第n个。 */
		for i := 1; i < n+1 ; i++  {		/* 枚举起点，从1开始到n，i表示起点下标，j表示终点下标， */
			j := i + len -1					/* 计算终点坐标 */
			if j > n {						/* 省去越界的部分 */
				continue
			}
			for k := i; k < j ; k++  {		/* 枚举区间分割点 */
				if dp[i][j] == 0 {			/* 这里我们要避免前值为0 */
					dp[i][j] = dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]
				}else{
					dp[i][j] = int(math.Min(float64(dp[i][j]),float64(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1])))
				}

			}
		}
	}
	util.Print2DArray(dp)
	return dp[1][n]
}
```

## 背包模型

为什么背包模型不属于线性模型？因为在01背包中物品只有一件，拿完之后 物品的种类会随之变化，所以说可以看作是有三个变量存在所以不能使用线性模型。

### 01背包问题

## 动态规划原理

虽然已经用动态规划方法解决了上面两个问题，但是大家可能还跟我一样并不知道什么时候要用到动态规划。总结一下上面的斐波拉契数列和钢条切割问题，发现两个问题都涉及到了重叠子问题，和最优子结构。

#### ①最优子结构

用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。

#### ②重叠子问题

在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。