## 线性模型🌾

**两个变量之间存在一次方函数关系，就称它们之间存在线性关系。**在线性结构上进行状态转移DP，统称线性DP，注意问题中的未知数只有两个那就是n和f(n)，比如说分金币问题中的coins总数和charge次数。下面拿实际问题来举例子。

**注意**：已知量数组不属于变量，比如说金币面额。

## 	切木棍🌿

给定一段长度为n英寸的钢条和一个价格表pi(i=1，2，...，n)，求解切割钢条方案，使得销售收益rn最大。注意，如果长度为n英寸的钢条价格pn足够大，最优解可能就是完全不需要切割。

![img](F:\我的笔记\53.算法\assets\200.jpg)

#### 思路🍀

考虑n=4的情况，我们所有可能的切割方案如下

![img](F:\我的笔记\53.算法\assets\4010043-b154f60e0b31a971.jpg)

我们将钢条从左边切割长度为i的一段，只对右边剩下的长度为n-i的一段继续进行切割（递归求解），对左边的一段则不再进行切割。即问题分解为：将长度为n的钢条分解为左边开始一段，以及对剩余部分继续分解的结果。这样，不做任何切割的方案可以描述为：第一段的长度为n，收益为pn，剩余部分长度为0，对应收益为r0=0。

#### 动态转移方程🍁

$$
f(l) = max(p^i + f(l-r^i))
$$

#### 暴力递归🥀

```go
func CutSteel(value []int, length int) int {
	if length == 0 {
		return 0
	}

	bestValue := math.MinInt64

	for i := 1; i <= length; i++ {
		preValue := value[i-1]+CutSteel(value,length-i)
		bestValue = int(math.Max(float64(preValue),float64(bestValue)))
	}
	return bestValue
}
```

####  动态规划写法🌷

对于rn（n![\geq](https://math.jianshu.com/math?formula=%5Cgeq)1）,可以用更短地钢条的最优收割收益来描述它：
$$
rn = max(p^n，r^1 + r^n-1 ，r^2 + r^n-2，...，r^n-1 + r^1)
$$

- pn对应不切割，直接出售长度为n英寸的钢条方案
- 其他n-1个参数对应另外n-1种切割方案：对每个i=1，2，...，n-1，首先将钢条切割长度为i和n-i的两段，接着求解这两段的最优收益ri和rn-i（每种方案的最优收益为两段的最优收益之和）

```go
func BottomUpCutSteel(v []int, n int) int {
	r := make([]int, n+1)
	/*
		创建备忘录，用于记录长度为i的时候的最优解。
		我们只要拿到了上一轮的最优解，下一轮只需要比较之前最优解的组合外加上当前长度不切割的价值就可以了，依此递推，
	*/
	for i := 1; i <= n; i++  {
		bestChoice := -1
		for j := 1; j <= i; j++ {
			bestChoice = int(math.Max(float64(bestChoice), float64(v[j-1] + r[i-j])))
		}
		r[i] = bestChoice
	}
	return r[len(r)-1]
}
```



## lis🌼

`longest increasing substring` 最长递增子序列，给定数组`arr`，返回`arr`的最长递增子序列。

#### 动态转移方程🌽

f(n)表示以下标为n结尾的数组的最长递增子序列的长度。
$$
f(n) = max(f(n-i) + 1) ~~~~(~arr[n] > arr[n-i]~)
$$

#### 暴力递归🍏

注意最后以为不一定就是最长递增子序列的结尾，所以要遍历每一位。

```go
func lisRecusive (arr []int) int {
	bestAns := math.MinInt64
	for i := len(arr)-1;i >= 0 ;i--  {
		bestAns = int(math.Max(float64(bestAns),float64(lis(arr,i))))
	}

	return bestAns
}

func lis(arr []int,n int) int {
	if n == 0 {
		return 1
	}

	bestAns := math.MinInt64

	for i := n ;i > 0 ;i-- {
		if arr[n] > arr[n-i] {
			bestAns = int(math.Max(float64(bestAns),float64(lis(arr,n-i)+1)))
		}
	}

	return bestAns
}
```

#### 动态规划解决🍐<img src="F:\我的笔记\53.算法\assets\image-20200104120117518.png" alt="image-20200104120117518" style="zoom:67%;" />

```go
func lisDynamic (arr []int) int {
	memory := make([]int,len(arr))
	memory[0] = 1
	for i := 1;i < len(arr);i++  {		//控制n
		for j := 0;j < i ;j++  {		//控制i
			if arr[j] < arr[i] {
				memory[i] = int(math.Max(float64(memory[j]+1),float64(memory[i])))
			}
		}
	}
	max := 0
	for _,item := range memory {
		max = int(math.Max(float64(item),float64(max)))
	}
	return max
}
```



## lcs🌻

`longest common substring` 最长公共子序列   给定数组`arr1，arr2`， 最长公共子序列。

#### 动态转移方程🍅

<img src="F:\我的笔记\53.算法\assets\image-20200104120155955.png" alt="image-20200104120155955" style="zoom:67%;" />

#### 暴力递归🍓

根据动态转移方程我们可以很轻松的写出递归方法

```go
func lcsRecursive(m,n []int,i,j int) int {
	if i == 0 || j == 0 {
		return 1
	}
	if m[i] == n[j] {
		return 1 + lcsRecursive(m,n,i-1,j-1)
	}else{
		return int(math.Max(float64(lcsRecursive(m,n,i-1,j)),float64(lcsRecursive(m,n,i,j-1))))
	}
}
```

#### 动态规划解决🍒

根据我们对dp数组进行分析不难推敲出规律，做出从下而上的动态规划解决方案即可。

![](F:\我的笔记\53.算法\assets\考场案件管理 (1)-1578111796361.png)

```go
func lcsRynamic(m,n []int) int {
	if len(m) == 0 || len(n) == 0 {
		return 0
	}

	linear_dp := make([][]int, len(m)+1)

	for idx := range linear_dp {
		linear_dp[idx] = make([]int, len(n)+1)
	}

	for i := 1; i < len(linear_dp); i++  {
		for j := 1; j < len(linear_dp[i]); j++  {
			if m[i-1] == n[j-1] {
				linear_dp[i][j] = linear_dp[i-1][j-1] + 1
			}else{
				linear_dp[i][j] = int(math.Max(float64(linear_dp[i-1][j]),float64(linear_dp[i][j-1])))
			}
		}
	}
	for idx := range linear_dp {
		fmt.Println(linear_dp[idx])
	}
	return linear_dp[len(m)][len(n)]
}
```



## 区间模型🌺

所谓区间dp，顾名思义就是在一段区间上的动态规划。它既要满足dp问题的最优子结构和无后效性外，还应该符合在区间上操作的特点。我的理解是往往会对区间进行合并操作。抑或是单个元素（可看成一个小区间）跨区间进行操作。例如括号匹配问题，石子合并问题（通过多次的相邻合并，最后实质上会产生跨区间的合并，如果你把其中的石子看作参考系的话就很容易感觉出来），还有在整数中插入运算符号的问题（利用运算符的优先级以及交换律可看出），这样以来，如果我们要得知一个大区间的情况，由于它必定是由从多个长度不一的小区间转移而来（转移情况未知），我们可以通过求得多个小区间的情况，从而合并信息，得到大区间。

**对于一个长度为n的区间，确定它的子区间需要首尾两个指针，显然子区间数量级为n2，那区间dp的复杂度也就为n2**

### 范式🌴

```go
for len := 2; len <= n; len++  {		/* 区间长度，在这道题里指的就是第1个到第n个。 */
    for i := 0; i < n ; i++  {			/* 枚举起点，从1开始到n，i表示起点下标，j表示终点下标， */
        j := i + len -1					/* 计算终点坐标 */
        if j >= n {						/* 省去越界的部分 */
            continue
        }
        for k := i; k < j ; k++  {		/* 枚举区间分割点 */
            //do something
        }
    }
}
```



## 石子合并问题🌹

有N堆石子排成一排，每堆石子有一定的数量。现要将N堆石子并成为一堆。合并的过程只能每次将相邻的两堆石子堆成一堆，每次合并花费的代价为这两堆石子的和，经过N-1次合并后成为一堆。求出总的代价最小值。

#### 动态转移方程🌳

$$
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+w[i][j]);
$$

#### 递归穷举解决🍃

递归的方法我们通过动态转移方程和容易就能写出来，不过这里我们要注意我注释的部分。

```go
func mergeStoneRecursive(sum []int, i, j int) int {
	if i == j {
		return 0
	}

	if j == i + 1 {
		return sum[j+1] - sum[i]
	}

	bestChoice := math.MaxInt64

	for k := i+1; k < j ; k++ {
		l := mergeStoneRecursive(sum,i,k-1) + mergeStoneRecursive(sum,k,j) + sum[j+1] - sum[i]
		r := mergeStoneRecursive(sum,i,k) + mergeStoneRecursive(sum,k+1,j) + sum[j+1] - sum[i]
		cbs := int(math.Min(float64(l),float64(r)))
		// 就以2，3，1为例，先合并2和3与先合并3和1的结果是不同的我们要取最小值。
		bestChoice = int(math.Min(float64(cbs),float64(bestChoice)))
	}

	if bestChoice == math.MaxInt64 {
		return 0
	}else{
		return bestChoice
	}
}
```

#### 备忘录优化🍂

如上文所说区间dp的数组是二维关于i和j的。

```go
func mergeStoneRecursiveMemorized(sum []int, memory [][]int, i, j int) int {
   if i == j {
      return 0
   }

   if memory[i][j] != 0 {
      return memory[i][j]
   }

   if j == i + 1 {
      memory[i][j] = sum[j+1] - sum[i]
      return memory[i][j]
   }

   bestChoice := math.MaxInt64

   for k := i+1; k < j ; k++ {
      l := mergeStoneRecursiveMemorized(sum,memory,i,k-1) + mergeStoneRecursiveMemorized(sum,memory,k,j) + sum[j+1] - sum[i]
      r := mergeStoneRecursiveMemorized(sum,memory,i,k) + mergeStoneRecursiveMemorized(sum,memory,k+1,j) + sum[j+1] - sum[i]
      cbs := int(math.Min(float64(l),float64(r)))
      bestChoice = int(math.Min(float64(cbs),float64(bestChoice)))
   }

   if bestChoice == math.MaxInt64 {
      return 0
   }else{
      memory[i][j] = bestChoice
      return bestChoice
   }
}
```

#### 动态规划解决🌱

设计动态规划写法之前，我们先分析一下上文的备忘录的结构。

![考场案件管理](F:\我的笔记\53.算法\assets\考场案件管理.png)

首先`i==j`时，合并次数为`0`，`j<i`时合并次数为`0`，`j = j+1`时合并次数为`sum[j]-sum[i-1]`，我更倾向于让数组最外面留一层作为初始值，所以i的下标从`1`开始，但是实际上区间是没有必要多出一圈的。

```go
func mergeStone(n int,w []int) int   {
	dp := make([][]int,n+1)
	for  i := 0; i < n+1 ; i ++  {
		dp[i] = make([]int,n+1)
	}
	/*声明dp数组*/
	sum := make([]int, n+1)
	for idx := 1; idx < len(sum); idx++ {
		for i := 1; i <= idx ; i++  {
			sum[idx] += w[i-1]
		}
	}
	/*计算组合石头花费（从0开始，0表示没有石头）*/
	for len := 2; len < n+1; len++  {		/* 区间长度，在这道题里指的就是第1个到第n个。 */
		for i := 1; i < n+1 ; i++  {		/* 枚举起点，从1开始到n，i表示起点下标，j表示终点下标， */
			j := i + len -1					/* 计算终点坐标 */
			if j > n {						/* 省去越界的部分 */
				continue
			}
			for k := i; k < j ; k++  {		/* 枚举区间分割点 */
				if dp[i][j] == 0 {			/* 这里我们要避免前值为0 */
					dp[i][j] = dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1]
				}else{
					dp[i][j] = int(math.Min(float64(dp[i][j]),float64(dp[i][k]+dp[k+1][j]+sum[j]-sum[i-1])))
				}

			}
		}
	}
	util.Print2DArray(dp)
	return dp[1][n]
}
```



## 背包模型💐

为什么背包模型不属于线性模型？因为在01背包中物品只有一件，拿完之后 物品的种类会随之变化，所以说可以看作是有三个变量存在所以不能使用线性模型。

## 01背包问题🌸

[详见笔记]()

