## 前言

动态规划`（Dynamic Programming）`，当我们试着去解决有**重叠性**的问题时，使用动态规划往往是一个美好的解决方案，想要理解一个动态规划就要理解一个它的核心，动态规划算法的核心是下面的一张图片和一个小故事。

<img src="F:\我的笔记\53.算法\assets\20170715202503459.png" alt="img" style="zoom:75%;" />

```
A :  "1+1+1+1+1+1+1+1 =？" 
A :  "上面等式的值是多少"
B :  "8!"
A :  在上面等式的左边写上 "1+"
A :  "此时等式的值为多少"
B :  (quickly) "9!"
A :  "你怎么这么快就知道答案了"
A :  "只要在8的基础上加1就行了"
A :  "所以你不用重新计算,因为你记住了第一个等式的值为8!
-->   动态规划算法也可以说是 '记住求过的解来节省时间'。
```

由上面的图片和小故事可以知道动态规划算法的核心就是记住已经解决过的子问题的解。

## **动态规划算法的两种形式**

上面已经知道动态规划算法的核心是记住已经求过的解，记住求解的方式有两种：

- **自顶向下的备忘录法** 
- **自底向上。**

为了说明动态规划的这两种方法，举一个最简单的例子：求斐波拉契数列**Fibonacci** 。先看一下这个问题：

```go
Fibonacci (n) = 1;   n = 0
Fibonacci (n) = 1;   n = 1
Fibonacci (n) = Fibonacci(n-1) + Fibonacci(n-2)
```

这个算法使用递归十分的简单。先使用递归版本来实现这个算法：

```go
func fib(n int) int{
    if n<=0 {
        return 0
    }
    if n==1 {
        return 1        
    }
	return fib(n-1) + fib(n-2)
}
//输入6 -> 输出：8
```

先来分析一下递归算法的执行流程，假如输入6，那么执行的递归树如下：

<img src="F:\我的笔记\53.算法\assets\20170715205029376.png" alt="20170715205029376" style="zoom:75%;" />



上面的递归树中的每一个子节点都会执行一次，很多重复的节点被执行，fib(2)被重复执行了5次。由于调用每一个函数的时候都要保留上下文，所以空间上开销也不小。这么多的子节点被重复执行，如果在执行的时候把执行过的子节点保存起来，后面要用到的时候直接查表调用的话可以节约大量的时间。下面就看看动态规划的两种方法怎样来解决斐波拉契数列Fibonacci 数列问题。

### 自顶而下的备忘录法

备忘录法也是比较好理解的，创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在Memo数组中，下次在调用fib（n）的时候就不会重新递归了。之所以要用容量为n+1的数组是因为我们输入的**index**不是真正的**index**，而**index+1**。

```go
func fib (n int) int {
	if n <= 0 {
		return n
	}
	arr := make([]int ,n+1)
	for idx := range arr {
		arr[idx] = -1
	}
	return fibDypBackward(arr,n)
}

func fibDypBackward(arr []int, n int) int {
	if arr[n] != -1 {
		return arr[n]
	}
	if n <= 2 {
		return 1
	}
	arr[n] = fibDypBackward(arr, n-1) + fibDypBackward(arr, n-2)
	return arr[n]
}
```

比如上面的递归树中在计算fib（6）的时候先计算fib（5），调用fib（5）算出了fib（4）后，fib（6）再调用fib（4）就不会在递归fib（4）的子树了，因为fib（4）的值已经保存在Memo[4]中。

### 自上而下的动态规划

备忘录法还是利用了递归，上面算法不管怎样，计算fib（6）的时候最后还是要计算出`fib(1)，fib(2)，fib(3)`,那么何不先计算出`fib(1)，fib(2)，fib(3)`呢？这也就是动态规划的核心，先计算子问题，再由子问题计算父问题。

```go
func fibDyp(n int) int {
	if n <= 0 {
		return n
	}
	arr := make([]int ,n+1)
	arr[0] = 0
	arr[1] = 1
	for i := 2; i < len(arr); i++ {
		arr[i] = arr[i-1] + arr[i-2]
	}
	return arr[n]
}
```

一般来说由于备忘录方式的动态规划方法使用了递归，递归的时候会产生额外的开销，使用自底向上的动态规划方法要比备忘录方法好。你以为看懂了上面的例子就懂得了动态规划吗？那就`too young too simple`了。动态规划远远不止如此简单，下面先给出一个例子看看能否独立完成。然后再对动态规划的其他特性进行分析。


