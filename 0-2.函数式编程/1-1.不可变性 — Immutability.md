## Immutability

在计算机科学体系中，提及起不可变性，我们常指不可变数据 `immutable data`、不可变对象 `immutable objects`，数据结构、状态和变量都可能是不可变性的一个实例。

不变性在软件开发领域并不是一个新概念，但它在最近几年已经出现了上升趋势。从谷歌开始搜索不可变的趋势如下，从2013年开始稳步增长。

![Image for post](assets/1*Jo4TJWhm4cwS8YSrd4cokg.png)

在 `JavaScript` 领域，对不可变性的推动尤为强烈，巧合的是(也许不是)，`Facebook`在 `2013` 年发布了 `React.js`，正好是这一趋势上升的开始。紧随其后的是一个不为人所知的但非常常用的 `Immutable.js`。

不变性是函数编程（`FP`）范式的关键点，而 `FP` 范式又是基于 `lambda` 演算的。 `FP` 将计算视为对状态的数学函数的传值，并返回值计算状态的**副本**，而不是改变实际状态。

### immutable object

不可变对象(通常)定义为其状态在创建后不能被修改的对象。不过，也有一些人认为对象是不可变的，即使内部使用的属性发生了变化，只要对象从外部角度看没有发生变化，在编程语言中也就是我们常说的指针指向没有发生变化 (这通常被称为浅不变性。)

## why Immutability ？

不变性之所以重要，主要是因为它带来了线程安全性和没有副作用，并且使代码更容易调试、测试和理解。让我们回顾一下。

![Image result for immutable](assets/1*RxkciPHQuFv-zcWMGImtsw.png)

### Thread safety

当前提高程序执行速度的首选策略是使用多个内核。如果可变的状态在线程之间共享，则这种状态不能在多个内核之间并行使用，因为它们不是线程安全的。 对于不可变的对象，由于无法修改状态，因此访问对象并在内核之间分配状态不会引起竞争状况或同步问题，因此不需要任何锁操作或者同步操作。

虽然对于性能和内存使用来说，突变确实是最佳的，但除非内存是最重要的(如果硬件是限制的话，它可能会这样做)，但是内存比以前更强大。不可变对象影响性能的风险很低，垃圾收集器将为我们清理未使用的引用，因此占用内存或内存泄漏应该不是问题。

### No side effects

如果某个操作，函数或表达式在其局部作用域之外修改了某些状态变量值，则认为那是是副作用。 修改静态全局变量，修改通过引用(指针)传递的可变参数，执行 `I / O` 或调用其他副作用函数也是如此。 也就是说，如果它不仅仅返回一个值，那就是副作用。

具有副作用的功能是不可预测的，因为它取决于系统的状态。 如果可变的结构在过程中间中断(由于某些意外的原因)，则状态需要回滚到先前的有效版本，否则状态将保持未知状态。 

```go
isProcessing := false

func someProcess(path: string) {
  isProcessing = true
  if _, err := ioutil.ReadFile(path); err != nil {
    isProcessing = false // rollback
  }
}
```

如果某个函数没有副作用，则可以随时执行该函数，并且只要输入相同，就将始终返回相同的输出。它还可以自然避免状态变化，并迫使开发人员让数据流过并在程序中以其他方式使用。 这不仅使其更具可预测性，而且使其更具模块化。 没有状态的依赖性，不变的数据和类型可能更容易在其他上下文中重用。

然而，完全没有副作用是不可能的，也是不可取的，但它们可以限制在需要的时候。没有副作用，程序是纯粹的，只做计算，而且程序经常需要一些副作用，比如写入数据库或文件以及与外部系统集成。

### Easier to understand

当一个新的开发人员开始处理以前的项目时，他们希望以前的开发人员编写的代码是容易理解的。如果在系统中出现错误，开发人员不希望跟踪变量以找到它未定义的确切行。如果一个函数独立于全局状态，那么就更容易理解它是如何工作的。当一个变量是不可变的，它将被定义为一个值，并保持这个值，永远不会改变。

### Testability

如果某个功能模块有副作用，则可能取决于传参的顺序或其环境。调试这种功能很困难，因为它需要有关上下文。更糟糕的情况是，如果在应用程序的多个部分中使用结构，而一个部分中的突变在另一部分中创建了错误。 然后，问题的根源就出在故障范围之外，这是很难跟踪的。 如果函数是不可变的，则无需检查其实现，因为它没有副作用。

不可变的数据在其构造期间只能更改一次，因此，它更易于进行单元测试。 减少程序的可能突变量也可以被认为是减少潜在错误的发生。 由于测试是一种验证程序中的突变正确发生的方法，因此程序中较少的突变和较少的状态转换等于较少的测试，并且较少出现错误的原因。

### Values instead of places

通常，我们希望按照世界如何运转来建模事物。 问题在于，有多种方法将世界视为一个状态。 一种方法是将世界视为可变的对象，世界的某些部分会随着时间的变化而变化，经过变迁有些部分会消失，新部分会出现，这会带来问题。

抽象描述世界的另一种方法是将世界看成一个根据时间不断变化的值。在某一时刻，世界作为一个状态存在。 在另一个时刻，可能一个已经不存在的旧状态出现了一个新世界。 两种思想流派都以世界为模型，但根据对世界的看法，结果是不同的。

值(`value`)是事实，事实是不可改变的。有人可能会说事实是会改变的，比如说一个人的年龄，一股人群的数量。这确实是看待问题的一种方式，但是有理由认为那不是同一个人，或同一组(不可能是同一组，因为他们的状态不相等)，事情就会变得容易。区别在于身份和状态。身份是一样的，但状态改变了。比如说 `2019` 年的我和 `2020` 年的我可以视作两个完全不同的 `state`，或者上一分和这一分的那组人，都是不同的状态。

`Rich Hickey`介绍了面向位置的编程（`PLOP`）和基于值的编程（`VOP`）的术语。`PLOP`专注于位置（对内存中位置的引用），而 `VOP` 专注于值。 如果变量是一个值，我们可以保证它永远保持不变。 任何差异都应反映在新变量，新值中。 也就是说，如果状态中的某些内容发生更改，则它是一个新状态。 因此，整个状态可以看作是一个值。

## When not ?

### Quality of code

如果修改一个变量可以使一段代码做得更好、更简单、更清晰，那么这可能是修改它的一个原因，尽管需要记住它的缺点。

![Image for post](assets/0*tAUKboAiEerUcPvx.png)

### Frequently mutating properties

如果对象经常更改，那么为每次更改创建一个新实例可能不是一个好主意，这方面的例子是模拟和游戏，其中每秒更新好几次。在这种情况下使用不可变性可能会对性能要求太高。

### Huge data structures

复制大型对象，如巨大的数据树，可能会占用大量内存。在这种情况下，可变的数据结构可能更可取。

### Top application state

我们希望我们的应用程序是状态机。 但是在某些情况下，我们需要可变性和副作用，例如，我们希望我们的手机在启动 `Spotify` 时对我们做出反应。 如果我们当前正在收听 `Storytel` 或正在观看 `Youtube`，则希望电话暂停这些流并更新 `UI`，以告知我们正在收听 `Spotify`。

## An example

以这段简单的 `JavaScript` 代码为例。

```js
var array = [1, 2, 3]
var other_array = array.push(4)
```

我们可能希望数组会保持不变，而 `other_array` 将成为 `[1,2,3,2]`，但事实并非如此。 这段代码所做的是，`other_array`将更新对数组的引用，而自身成为新数组的长度（`other_array` 将返回 `4`）如果数组是不可变的，则不会发生这种情况。

```js
Array.prorotype.push => function(value) {
	return this.slice().push(value)
}
```

通过上面代码我们可以对其进行改写。

## Conclusion

如我们所见，使用不可变数据时有很多好处，也需要权衡取舍。 考虑到不可变对象的简单性，假定它们没有状态（除了创建对象所处的状态），可能更容易推断。从中我们可以得出，不可变对象是值，其本质上是简单的。可变对象具有状态，并且可能发生不可预测的变化，从而使其变得更加复杂，并且可能更加难以理解。

不可变的对象是线程安全的，因此，对于多线程环境而言是不错的选择。 由于无法修改任何状态，因此不会发生争用条件。 不可变对象也可以在函数之间自由共享。 如果共享的对象是可变的，则可能必须创建防御性副本以确保其状态不会意外更改。 不可变对象没有问题，因为它无法更改状态。

通过限制可变性，可以减少应用程序或对象可能存在的状态数量。 状态状态越少，就越容易推断应用程序或对象，错误发生的可能性就越小，所需的测试也就越少。

使用不变性的权衡是创建全新对象以更改单个状态值的性能成本。 根据频率和大小，此成本可能重要，也可能不重要。

在大多数情况下，使用不可变数据的优势胜于不使用不可变数据的劣势，但是，无状态应用程序在大多数情况下是无用的，因此我们需要进行一些突变。 重要的是我们将其最小化。 除非某些东西必须可变，否则请使其（或使其）不变。 消除的突变越多越好。

这并不意味着我们必须从头开始重做整个可变的应用程序，这可能是一件繁重的工作（有时在开发过程中更改结构范例可能会弊大于利），但如果可能的话，我们可以 开始在项目中逐步实现不可变类型。

程序中存在一系列易于实现且难以检测的错误，可以使用不可变的对象彻底消除这些错误，例如同步故障或在存储对它的引用之前克隆对象。 总是问自己或橡皮鸭，是否可以将您的类，函数或对象实现为不可变的类型，通常不是，答案是肯定的。