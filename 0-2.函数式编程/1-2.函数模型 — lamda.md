## Lamda

上一节我们说过不变性是函数编程（`FP`）范式的关键点，而 `FP` 范式又是基于 `lambda` 演算的。 `FP` 将计算视为对状态的数学函数的传值，并返回值计算状态的**副本**，而不是改变实际状态。

要了解一个事物，先了解它的历史一定是重中之重。`lamda` 表达式最初是由一个美国普林斯顿大学的数学家 `Alonzo Church` 在 `1932` 年所发明的。他也是"计算机科学之父"——图灵的博士生导师。

我们都知道现代的计算机基本上都是基于图灵机的。在图灵机中，所有的计算过程其实都是基于状态的，这也是为什么我们平常写代码要声明并使用变量的原因：**变量主要作用就是用来存储状态**。而 `Alonzo Church` 所提出的 `lamda` 演算(`lamda calcus`)模型实际上是基于函数的。图灵机模型和 `Lambda` 演算模型虽然是两种不同的理论模型，但它们实际上是等价的，这也意味着，任何基于图灵机的计算机程序都能等价地翻译成基于 `lambda` 演算模型的程序。

`lambda` 演算是一套研究函数定义、函数应用和递归的形式系统。它基本的组成部分就是三种表达式:

1. 函数定义 
2. 标识符引用
3. 函数应用。

那么到底什么是 `lamda` 表达式呢，它又是由哪些基本组成要素构成的呢？我们都知道在函数式编程语言里面，最基本的组成单位就是函数。`lambda` 表达式从定义上来讲可以看做是一个匿名的纯函数。`ES6` 中引入了箭头函数，它的本质实际上就是我们这里所说的 `lambda` 表达式:

```js
const lambda = x => x + 1;
```

`lamdba` 演算模型不是基于状态的，所以在 `ES6` 中箭头函数没有自己的 `this` ，实际上现在大部分的编程语言都引入了 `lambda` 表达式这一特性，如 `Java`, `c#` 和 `es6` 等。我们通常将 `lambda` 表达式，看作是一个黑盒，只关心它的输入和输出。由于没有内部状态，用函数式编程的思想写代码就与用命令式语言写代码截然不同。作为一个纯函数，每一次运行定义好的`lambda` 表达式的时候，结果都应该是一致的。


在纯粹的 `lambda` 演算中实际上是没有任何内置的数据结构和逻辑控制语句的，但是我们可以使用函数来建构整个编程语言的所有要素。

`lambda` 演算中的一些基本规则，可以类比到我们比较熟悉的 `ES6` 语法:

|                  | lambda表达式     | ES6 箭头函数              |
| ---------------- | ---------------- | ------------------------- |
| 定义函数         | λx.x             | x => x                    |
| 柯里化 curry     | λx. λy.x+y       | x => y => x + y           |
| 应用 application | (λx. λy.x+y) 5 1 | (x => y => x + y) (5) (1) |

## 实现

在实现具体的逻辑之前，我们需要明确的一点是：在 `lambda` 演算中，`lambda` 表达式本身既可以是操作数也可以是函数，就好像一只鸡(`lambda` 表达式），既可以吃虫子（另一个 `lambda` 表达式)，也可以被狐狸(还有一个 `lambda` 表达式) 吃（请原谅我这糟糕的类比），它们统称为动物( `lambda`表达式）。归根结底就是，在这个封闭的概念世界里，只有一类事物，那就是`lambda` 表达式(函数)，我们可以利用这个最基础的概念生成其它的概念和运算逻辑。

在纯粹的函数式编程世界里，没有`1`, `2`, `3` 这样的数字也没有 `+-*/` 这样的基本运算符，这些我们都需要自己手动去实现。

### 数字

首先作为一门计算机设计语言，数字是关键，所谓”数是万物本源“在计算机世界里简直就是真理。那么我们如何利用 `lamda`表达式来表示数呢？在这里，我们采用函数调用次数来表示自然数，用这样的编码方式表示的自然数也叫*邱奇数*。